<!DOCTYPE html>
<html class="wf-firasans-n4-active wf-firasans-n7-active wf-raleway-n7-active wf-firasans-i7-active wf-firasans-i4-active wf-active" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="profile" href="http://gmpg.org/xfn/11">

<title>Algorithmic and Information Theoretic Decoding Thresholds for Low density Parity-Check Code – Windows On Theory</title>
<script id="twitter-wjs" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/widgets.js"></script><script src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/webfont.js" type="text/javascript" async=""></script><script type="text/javascript">
  WebFontConfig = {"google":{"families":["Fira+Sans:r,i,b,bi:latin,latin-ext","Raleway:b:latin,latin-ext"]}};
  (function() {
    var wf = document.createElement('script');
    wf.src = 'https://s0.wp.com/wp-content/plugins/custom-fonts/js/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
	})();
</script><style id="jetpack-custom-fonts-css">.wf-active body{font-family:"Fira Sans",sans-serif;font-size:15.9px}.wf-active button, .wf-active input[type="button"], .wf-active input[type="reset"], .wf-active input[type="submit"]{font-family:"Fira Sans",sans-serif}.wf-active pre{font-family:"Fira Sans",sans-serif;font-size:15.9px}.wf-active sub, .wf-active sup{font-size:0.86125em}.wf-active small{font-size:0.86125em}.wf-active big{font-size:1.27em}.wf-active .site-footer{font-size:0.86125em}.wf-active .entry-footer, .wf-active .entry-meta{font-size:0.86125em}.wf-active .wp-caption-text{font-size:0.86125em}.wf-active .gallery-caption{font-size:0.86125em}.wf-active .site-main .paging-navigation, .wf-active .site-main .post-navigation{font-size:0.86125em}.wf-active .site-main .comment-navigation{font-size:0.86125em}.wf-active .comment-meta .comment-metadata{font-size:0.86125em}.wf-active .comment-form-author label, .wf-active .comment-form-comment label, .wf-active .comment-form-email label, .wf-active .comment-form-url label{font-size:0.86125em}.wf-active #infinite-footer .blog-credits, .wf-active #infinite-footer .blog-info a{font-size:0.86125em}.wf-active #infinite-handle span{font-size:0.86125em}@media screen and (min-width: 50em){.wf-active .entry-content, .wf-active blockquote{font-size:1.27em}}@media screen and (min-width: 50em){.wf-active blockquote cite{font-size:0.86125em}}.wf-active h1, .wf-active h2, .wf-active h3, .wf-active h4, .wf-active h5, .wf-active h6, .wf-active .site-title{font-family:"Raleway",sans-serif;font-style:normal;font-weight:700}.wf-active h1{font-size:26.3px;font-weight:700;font-style:normal}.wf-active h2{font-size:18.8px;font-weight:700;font-style:normal}.wf-active #respond h3, .wf-active h3{font-size:18.8px;font-weight:700;font-style:normal}.wf-active h4{font-size:15px;font-weight:700;font-style:normal}.wf-active h5{font-size:15px;font-weight:700;font-style:normal}.wf-active h6{font-size:13.2px;font-weight:700;font-style:normal}.wf-active .site-title{font-size:24.4px;font-style:normal;font-weight:700}.wf-active .site-description{font-size:15px;font-weight:700;font-style:normal}.wf-active .entry-title{font-size:1.645em;font-style:normal;font-weight:700}.wf-active .page-title{font-size:16.9px;font-style:normal;font-weight:700}.wf-active #respond h3, .wf-active .comments-title{font-size:1.13em;font-style:normal;font-weight:700}.wf-active .widget-title{font-size:16.9px;font-weight:700;font-style:normal}@media screen and (min-width: 50em){.wf-active h1{font-size:30.1px;font-weight:700;font-style:normal}}@media screen and (min-width: 50em){.wf-active h2{font-size:26.3px;font-weight:700;font-style:normal}}@media screen and (min-width: 50em){.wf-active #respond h3, .wf-active h3{font-size:22.6px;font-weight:700;font-style:normal}}@media screen and (min-width: 50em){.wf-active h4{font-size:18.8px;font-weight:700;font-style:normal}}@media screen and (min-width: 50em){.wf-active .entry-title{font-size:30.1px;font-style:normal;font-weight:700}}</style>

<!-- Async WordPress.com Remote Login -->

<link rel="dns-prefetch" href="https://s0.wp.com/">
<link rel="dns-prefetch" href="https://windowsontheory.wordpress.com/">
<link rel="alternate" type="application/rss+xml" title="Windows On Theory » Feed" href="https://windowsontheory.org/feed/">
<link rel="alternate" type="application/rss+xml" title="Windows On Theory » Comments Feed" href="https://windowsontheory.org/comments/feed/">
	<script type="text/javascript">
		/* <![CDATA[ */
		function addLoadEvent(func) {
			var oldonload = window.onload;
			if (typeof window.onload != 'function') {
				window.onload = func;
			} else {
				window.onload = function () {
					oldonload();
					func();
				}
			}
		}
		/* ]]> */
	</script>
			<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s0.wp.com\/wp-content\/mu-plugins\/wpcom-smileys\/twemoji\/2\/72x72\/","ext":".png","svgUrl":"https:\/\/s0.wp.com\/wp-content\/mu-plugins\/wpcom-smileys\/twemoji\/2\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/s0.wp.com\/wp-includes\/js\/wp-emoji-release.min.js?m=1605528427h&ver=5.6-RC5-49737"}};
			!function(e,a,t){var r,n,o,i,p=a.createElement("canvas"),s=p.getContext&&p.getContext("2d");function c(e,t){var a=String.fromCharCode;s.clearRect(0,0,p.width,p.height),s.fillText(a.apply(this,e),0,0);var r=p.toDataURL();return s.clearRect(0,0,p.width,p.height),s.fillText(a.apply(this,t),0,0),r===p.toDataURL()}function l(e){if(!s||!s.fillText)return!1;switch(s.textBaseline="top",s.font="600 32px Arial",e){case"flag":return!c([127987,65039,8205,9895,65039],[127987,65039,8203,9895,65039])&&(!c([55356,56826,55356,56819],[55356,56826,8203,55356,56819])&&!c([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]));case"emoji":return!c([55357,56424,8205,55356,57212],[55357,56424,8203,55356,57212])}return!1}function d(e){var t=a.createElement("script");t.src=e,t.defer=t.type="text/javascript",a.getElementsByTagName("head")[0].appendChild(t)}for(i=Array("flag","emoji"),t.supports={everything:!0,everythingExceptFlag:!0},o=0;o<i.length;o++)t.supports[i[o]]=l(i[o]),t.supports.everything=t.supports.everything&&t.supports[i[o]],"flag"!==i[o]&&(t.supports.everythingExceptFlag=t.supports.everythingExceptFlag&&t.supports[i[o]]);t.supports.everythingExceptFlag=t.supports.everythingExceptFlag&&!t.supports.flag,t.DOMReady=!1,t.readyCallback=function(){t.DOMReady=!0},t.supports.everything||(n=function(){t.readyCallback()},a.addEventListener?(a.addEventListener("DOMContentLoaded",n,!1),e.addEventListener("load",n,!1)):(e.attachEvent("onload",n),a.attachEvent("onreadystatechange",function(){"complete"===a.readyState&&t.readyCallback()})),(r=t.source||{}).concatemoji?d(r.concatemoji):r.wpemoji&&r.twemoji&&(d(r.twemoji),d(r.wpemoji)))}(window,document,window._wpemojiSettings);
		</script><script src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/wp-emoji-release.js" type="text/javascript" defer="defer"></script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
	<link rel="stylesheet" id="all-css-0-1" href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/a_004.css" type="text/css" media="all">
<style id="wp-block-library-inline-css">
.has-text-align-justify {
	text-align:justify;
}
</style>
<style id="global-styles-inline-css">
:root{--wp--preset--color--dark-green: #1c7c7c;--wp--preset--color--dark-gray: #666;--wp--preset--color--medium-gray: #999;--wp--preset--color--light-gray: #eee;--wp--preset--color--white: #fff;--wp--preset--gradient--vivid-cyan-blue-to-vivid-purple: linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%);--wp--preset--gradient--light-green-cyan-to-vivid-green-cyan: linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%);--wp--preset--gradient--luminous-vivid-amber-to-luminous-vivid-orange: linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%);--wp--preset--gradient--luminous-vivid-orange-to-vivid-red: linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%);--wp--preset--gradient--very-light-gray-to-cyan-bluish-gray: linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%);--wp--preset--gradient--cool-to-warm-spectrum: linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%);--wp--preset--gradient--blush-light-purple: linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%);--wp--preset--gradient--blush-bordeaux: linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%);--wp--preset--gradient--luminous-dusk: linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%);--wp--preset--gradient--pale-ocean: linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%);--wp--preset--gradient--electric-grass: linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%);--wp--preset--gradient--midnight: linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%);--wp--preset--font-size--small: 13px;--wp--preset--font-size--normal: 16px;--wp--preset--font-size--medium: 20px;--wp--preset--font-size--large: 36px;--wp--preset--font-size--huge: 42px;--wp--preset--font-style--normal: normal;--wp--preset--font-style--italic: italic;--wp--preset--font-weight--100: 100;--wp--preset--font-weight--200: 200;--wp--preset--font-weight--300: 300;--wp--preset--font-weight--400: 400;--wp--preset--font-weight--500: 500;--wp--preset--font-weight--600: 600;--wp--preset--font-weight--700: 700;--wp--preset--font-weight--800: 800;--wp--preset--font-weight--900: 900;--wp--preset--text-decoration--underline: underline;--wp--preset--text-decoration--strikethrough: line-through;--wp--preset--text-transform--uppercase: uppercase;--wp--preset--text-transform--lowercase: lowercase;--wp--preset--text-transform--capitalize: capitalize;}.has-dark-green-color{color: #1c7c7c;}.has-dark-green-background-color{background-color: #1c7c7c;}.has-dark-gray-color{color: #666;}.has-dark-gray-background-color{background-color: #666;}.has-medium-gray-color{color: #999;}.has-medium-gray-background-color{background-color: #999;}.has-light-gray-color{color: #eee;}.has-light-gray-background-color{background-color: #eee;}.has-white-color{color: #fff;}.has-white-background-color{background-color: #fff;}.has-vivid-cyan-blue-to-vivid-purple-gradient-background{background: linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%);}.has-light-green-cyan-to-vivid-green-cyan-gradient-background{background: linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%);}.has-luminous-vivid-amber-to-luminous-vivid-orange-gradient-background{background: linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%);}.has-luminous-vivid-orange-to-vivid-red-gradient-background{background: linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%);}.has-very-light-gray-to-cyan-bluish-gray-gradient-background{background: linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%);}.has-cool-to-warm-spectrum-gradient-background{background: linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%);}.has-blush-light-purple-gradient-background{background: linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%);}.has-blush-bordeaux-gradient-background{background: linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%);}.has-luminous-dusk-gradient-background{background: linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%);}.has-pale-ocean-gradient-background{background: linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%);}.has-electric-grass-gradient-background{background: linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%);}.has-midnight-gradient-background{background: linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%);}.has-small-font-size{font-size: 13px;}.has-normal-font-size{font-size: 16px;}.has-medium-font-size{font-size: 20px;}.has-large-font-size{font-size: 36px;}.has-huge-font-size{font-size: 42px;}.has-normal-font-style{font-style: normal;}.has-italic-font-style{font-style: italic;}.has-100-font-weight{font-weight: 100;}.has-200-font-weight{font-weight: 200;}.has-300-font-weight{font-weight: 300;}.has-400-font-weight{font-weight: 400;}.has-500-font-weight{font-weight: 500;}.has-600-font-weight{font-weight: 600;}.has-700-font-weight{font-weight: 700;}.has-800-font-weight{font-weight: 800;}.has-900-font-weight{font-weight: 900;}.has-underline-text-decoration{text-decoration: underline;}.has-strikethrough-text-decoration{text-decoration: line-through;}.has-uppercase-text-transform{text-transform: uppercase;}.has-lowercase-text-transform{text-transform: lowercase;}.has-capitalize-text-transform{text-transform: capitalize;}
</style>
<link rel="stylesheet" id="all-css-2-1" href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/a_005.css" type="text/css" media="all">
<link rel="stylesheet" id="print-css-3-1" href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/global-print.css" type="text/css" media="print">
<style id="jetpack-global-styles-frontend-style-inline-css">
:root { --font-headings: unset; --font-base: unset; --font-headings-default: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif; --font-base-default: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;}
</style>
<link rel="stylesheet" id="all-css-6-1" href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/a_003.css" type="text/css" media="all">
<link rel="stylesheet" href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/css.css" media="all"><script id="jetpack_related-posts-js-extra">
var related_posts_js_options = {"post_heading":"h4"};
</script>
<script id="wpcom-actionbar-placeholder-js-extra">
var actionbardata = {"siteID":"32349634","siteName":"Windows On Theory","siteURL":"https:\/\/windowsontheory.org","icon":"<img alt='' src='https:\/\/s0.wp.com\/i\/logo\/wpcom-gray-white.png' class='avatar avatar-50' height='50' width='50' \/>","canManageOptions":"","canCustomizeSite":"","isFollowing":"","themeSlug":"pub\/penscratch-2","signupURL":"https:\/\/wordpress.com\/start\/","loginURL":"https:\/\/wordpress.com\/log-in?redirect_to=https%3A%2F%2Fwindowsontheory.org%2F2018%2F12%2F16%2Falgorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code%2F&signup_flow=account&domain=windowsontheory.org","themeURL":"https:\/\/wordpress.com\/theme\/penscratch-2\/","xhrURL":"https:\/\/windowsontheory.org\/wp-admin\/admin-ajax.php","nonce":"c86e48aff3","isSingular":"1","isFolded":"","isLoggedIn":"","isMobile":"","subscribeNonce":"<input type=\"hidden\" id=\"_wpnonce\" name=\"_wpnonce\" value=\"116d41c26a\" \/>","referer":"https:\/\/windowsontheory.org\/2018\/12\/16\/algorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code\/","canFollow":"1","feedID":"1661722","statusMessage":"","customizeLink":"https:\/\/windowsontheory.wordpress.com\/wp-admin\/customize.php?url=https%3A%2F%2Fwindowsontheory.wordpress.com%2F2018%2F12%2F16%2Falgorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code%2F","postID":"6363","shortlink":"https:\/\/wp.me\/p2bJCi-1ED","canEditPost":"","editLink":"https:\/\/wordpress.com\/post\/windowsontheory.org\/6363","statsLink":"https:\/\/wordpress.com\/stats\/post\/6363\/windowsontheory.org","i18n":{"view":"View site","follow":"Follow","following":"Following","edit":"Edit","login":"Log in","signup":"Sign up","customize":"Customize","report":"Report this content","themeInfo":"Get theme: Penscratch 2","shortlink":"Copy shortlink","copied":"Copied","followedText":"New posts from this site will now appear in your <a href=\"https:\/\/wordpress.com\/read\">Reader<\/a>","foldBar":"Collapse this bar","unfoldBar":"Expand this bar","editSubs":"Manage subscriptions","viewReader":"View site in Reader","viewReadPost":"View post in Reader","subscribe":"Sign me up","enterEmail":"Enter your email address","followers":"Join 724 other followers","alreadyUser":"Already have a WordPress.com account? <a href=\"https:\/\/wordpress.com\/log-in?redirect_to=https%3A%2F%2Fwindowsontheory.org%2F2018%2F12%2F16%2Falgorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code%2F&signup_flow=account&domain=windowsontheory.org\">Log in now.<\/a>","stats":"Stats"}};
</script>
<script type="text/javascript" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/a.js"></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://windowsontheory.wordpress.com/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://s0.wp.com/wp-includes/wlwmanifest.xml"> 
<meta name="generator" content="WordPress.com">
<link rel="canonical" href="https://windowsontheory.org/2018/12/16/algorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code/">
<link rel="shortlink" href="https://wp.me/p2bJCi-1ED">
<link rel="alternate" type="application/json+oembed" href="https://public-api.wordpress.com/oembed/?format=json&amp;url=https%3A%2F%2Fwindowsontheory.org%2F2018%2F12%2F16%2Falgorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code%2F&amp;for=wpcom-auto-discovery"><link rel="alternate" type="application/xml+oembed" href="https://public-api.wordpress.com/oembed/?format=xml&amp;url=https%3A%2F%2Fwindowsontheory.org%2F2018%2F12%2F16%2Falgorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code%2F&amp;for=wpcom-auto-discovery">
<!-- Jetpack Open Graph Tags -->
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithmic and Information Theoretic Decoding Thresholds for Low density Parity-Check Code">
<meta property="og:url" content="https://windowsontheory.org/2018/12/16/algorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code/">
<meta property="og:description" content="by Jeremy Dohmann, Vanessa Wong, Venkat Arun Abstract We will discuss error-correcting codes: specifically, low-density parity-check (LDPC) codes. We first describe their construction and informati…">
<meta property="article:published_time" content="2018-12-17T01:16:55+00:00">
<meta property="article:modified_time" content="2018-12-20T12:36:32+00:00">
<meta property="og:site_name" content="Windows On Theory">
<meta property="og:image" content="https://windowsontheory.files.wordpress.com/2018/12/graph.png">
<meta property="og:image:width" content="872">
<meta property="og:image:height" content="368">
<meta property="og:locale" content="en_US">
<meta name="twitter:site" content="@wordpressdotcom">
<meta name="twitter:text:title" content="Algorithmic and Information Theoretic Decoding Thresholds for Low density Parity-Check&nbsp;Code">
<meta name="twitter:image" content="https://windowsontheory.files.wordpress.com/2018/12/encodedecode.png?w=144">
<meta name="twitter:card" content="summary">
<meta property="article:publisher" content="https://www.facebook.com/WordPresscom">

<!-- End Jetpack Open Graph Tags -->
<link rel="shortcut icon" type="image/x-icon" href="https://s0.wp.com/i/favicon.ico" sizes="16x16 24x24 32x32 48x48">
<link rel="icon" type="image/x-icon" href="https://s0.wp.com/i/favicon.ico" sizes="16x16 24x24 32x32 48x48">
<link rel="apple-touch-icon" href="https://s0.wp.com/i/webclip.png">
<link rel="openid.server" href="https://windowsontheory.org/?openidserver=1">
<link rel="openid.delegate" href="https://windowsontheory.org/">
<link rel="search" type="application/opensearchdescription+xml" href="https://windowsontheory.org/osd.xml" title="Windows On Theory">
<link rel="search" type="application/opensearchdescription+xml" href="https://s1.wp.com/opensearch.xml" title="WordPress.com">
<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>		<style type="text/css">
			.recentcomments a {
				display: inline !important;
				padding: 0 !important;
				margin: 0 !important;
			}

			table.recentcommentsavatartop img.avatar, table.recentcommentsavatarend img.avatar {
				border: 0px;
				margin: 0;
			}

			table.recentcommentsavatartop a, table.recentcommentsavatarend a {
				border: 0px !important;
				background-color: transparent !important;
			}

			td.recentcommentsavatarend, td.recentcommentsavatartop {
				padding: 0px 0px 1px 0px;
				margin: 0px;
			}

			td.recentcommentstextend {
				border: none !important;
				padding: 0px 0px 2px 10px;
			}

			.rtl td.recentcommentstextend {
				padding: 0px 10px 2px 0px;
			}

			td.recentcommentstexttop {
				border: none;
				padding: 0px 0px 0px 10px;
			}

			.rtl td.recentcommentstexttop {
				padding: 0px 10px 0px 0px;
			}
		</style>
		<meta name="application-name" content="Windows On Theory"><meta name="msapplication-window" content="width=device-width;height=device-height"><meta name="msapplication-tooltip" content="A Research Blog"><meta name="msapplication-task" content="name=Subscribe;action-uri=https://windowsontheory.org/feed/;icon-uri=https://s0.wp.com/i/favicon.ico"><meta name="msapplication-task" content="name=Sign up for a free blog;action-uri=http://wordpress.com/signup/;icon-uri=https://s0.wp.com/i/favicon.ico"><meta name="msapplication-task" content="name=WordPress.com Support;action-uri=http://support.wordpress.com/;icon-uri=https://s0.wp.com/i/favicon.ico"><meta name="msapplication-task" content="name=WordPress.com Forums;action-uri=http://forums.wordpress.com/;icon-uri=https://s0.wp.com/i/favicon.ico"><meta name="description" content="by Jeremy Dohmann, Vanessa Wong, Venkat Arun Abstract We will discuss error-correcting codes: specifically, low-density parity-check (LDPC) codes. We first describe their construction and information-theoretical decoding thresholds, $latex p_{c}$.&nbsp; Belief propagation (BP) (see Tom's notes) can be used to decode these. We analyze BP to find the maximum error-rate upto which BP succeeds. After this…">
<link rel="amphtml" href="https://windowsontheory.org/2018/12/16/algorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code/amp/"><!-- Your Google Analytics Plugin is missing the tracking ID -->
<link rel="stylesheet" type="text/css" id="gravatar-card-css" href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/hovercard.css"><link rel="stylesheet" type="text/css" id="gravatar-card-services-css" href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/services.css"><link href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/actionbar.css" type="text/css" rel="stylesheet"><script charset="utf-8" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/momenttimelinetweet.js"></script><script charset="utf-8" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/timeline.js"></script></head>

<body class="post-template-default single single-post postid-6363 single-format-standard wp-embed-responsive customizer-styles-applied group-blog highlander-enabled highlander-light">
<div id="page" class="hfeed site">
	<a class="skip-link screen-reader-text" href="#content">Skip to content</a>
	<header id="masthead" class="site-header" role="banner">
		<div class="site-branding">
							<p class="site-title"><a href="https://windowsontheory.org/" rel="home">Windows On Theory</a></p>
							<p class="site-description">A Research Blog</p>
					</div>

		<nav id="site-navigation" class="main-navigation" role="navigation">
			<button class="menu-toggle">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><rect x="0" fill="none" width="16" height="16"></rect><g><path id="menu-icon" d="M0 14h16v-2H0v2zM0 2v2h16V2H0zm0 7h16V7H0v2z"></path></g></svg>
				Menu			</button>
			<div class="menu-menu-1-container"><ul id="menu-menu-1" class="menu nav-menu" aria-expanded="false"><li id="menu-item-3305" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-3305"><a href="https://windowsontheory.org/">Home</a></li>
<li id="menu-item-3306" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-3306"><a href="https://windowsontheory.org/about/">About</a></li>
</ul></div>		</nav><!-- #site-navigation -->
	</header><!-- #masthead -->

	<div id="content" class="site-content">
		
	<div id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
			
<article id="post-6363" class="post-6363 post type-post status-publish format-standard hentry category-physics tag-belief-propagation tag-coding-theory tag-cs229r tag-ldpc tag-statistical-physics tag-thresholding-behavior">
	<header class="entry-header">
		<h1 class="entry-title">Algorithmic and Information Theoretic Decoding Thresholds for Low density Parity-Check&nbsp;Code</h1>		
		<div class="entry-meta">
			<span class="posted-on"><a href="https://windowsontheory.org/2018/12/16/algorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code/" rel="bookmark"><time class="entry-date published" datetime="2018-12-16T20:16:55-05:00">December 16, 2018</time><time class="updated" datetime="2018-12-20T07:36:32-05:00">December 20, 2018</time></a></span><span class="byline"><span class="author vcard"><span class="sep"> ~ </span><a class="url fn n" href="https://windowsontheory.org/author/dohmanna47993cfd3/">Jeremy Dohmann</a></span></span>					</div><!-- .entry-meta -->
	</header><!-- .entry-header -->

	<div class="entry-content">
		<h3>by Jeremy Dohmann, Vanessa Wong, Venkat Arun</h3>

<h2>Abstract</h2>

<p>We will discuss error-correcting codes: specifically, low-density 
parity-check (LDPC) codes. We first describe their construction and 
information-theoretical decoding thresholds, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex">.&nbsp;</p>

<p>Belief propagation (BP) (<a href="https://d1b10bmlvqabco.cloudfront.net/attach/jjsqup73w3r2s3/ihaz9phexeb6fb/jmch5yx8edqc/229R_Talk_Notes_2.pdf">see Tom’s notes</a>) can be used to decode these. We analyze BP to find the maximum error-rate upto which BP succeeds.</p>

<p>After this point, BP will reach a suboptimal fixed point with high 
probability. This is lower than the information-theoretic bound, 
illustrating a gap between algorithmic and information-theoretic 
thresholds for decoding.</p>

<p>Then we outline a proof of a theorem suggesting that any efficient 
algorithm, not just BP, will fail after the algorithmic threshold. This 
is because there is a phase transition at the algorithmic threshold, 
after which there exist an exponentially large number of suboptimal 
`metastable’ states near the optimal solution. Local search algorithms 
will tend to get stuck at these suboptimal points.</p>

<h3>Introduction to Error Correcting Codes</h3>

<h4>Motivation</h4>

<p>Alice wants to send a message to Bob, but their channel of 
communication is such that Bob receives a corrupted version of what 
Alice sent. Most practical communication devices are imperfect and 
introduce errors in the messages they are transmitting. For instance, if
 Alice sends 3V, Bob will really receive three volts plus some noise (we
 have chosen to ignore some inconvenient practical details here). In 
many cases, this noise is quite small, e.g. it could be less than 0.5V 
in 99.99% of cases. So, in principle, Alice could have had <em>very </em>reliable
 delivery by just choosing to always send 0V for a logical 0 and 5V for 
logical 1, using checksums to detect the occasional error. But this is 
wasteful. Alice could have squeezed more levels between 0 and 5V to get a
 higher bitrate. This causes errors, but Alice can introduce redundancy 
in the bits she is transmitting which can enable Bob to decode the 
correct message with high probability. Since it is much easier to 
control redundancy in encoding than in physical quantities, practical 
communication devices often choose choose to pack enough bits into their
 physical signal that errors are relatively quite likely, relying 
instead on redundancy in their encoding to recover from the errors. 
Redundancy is also used in storage, where we don’t have the option of 
detecting an error and retransmitting the message.</p>

<p>Some errors in communication are caused by thermal noise. These are 
unpredictable and unavoidable, but the errors they cause can be easily 
modeled; they cause bit-flips in random positions in the message. There 
are other sources of error. The clocks on the two devices may not be 
correctly synchronized, causing systematic bit-flips in a somewhat 
predictable pattern. A sudden surge of current (e.g. because someone 
turned on the lights, and electricity sparked between the contacts) can 
corrupt a large contiguous segment of bits. Or the cable could simply be
 cut in which case no information gets through. These other kinds of 
errors are often harder to model (and easier to detect/mitigate), so we 
have to remain content with merely detecting them. Thus for the 
remainder of this blog post, we shall restrict ourselves to an error 
model where each bit is corrupted with some fixed (but potentially 
unknown) probability, independent of the other bits. For simplicity, we 
shall primarily consider the Binary Erasure Channel (BEC), where a bit 
either goes through successfully, or the receiver <em>knows </em>that there has been an error (though we will introduce some related channels along the way).</p>

<p>Claude Shannon found that given any channel, there is a bitrate below
 which it is possible to communicate reliably with vanishing error rate.
 Reliable communication cannot be achieved above this bitrate. Hence 
this threshold bitrate is called the channel capacity. He showed that 
random linear codes are an optimal encoding scheme that achieves channel
 capacity. We will only briefly discuss random linear codes, but 
essentially they work by choosing random vectors in the input space and 
mapping them randomly to vectors in the encoded space. Unfortunately we 
do not have efficient algorithms for decoding these codes (mostly due to
 the randomness in their construction), and it is conjectured that one 
doesn’t exist. Recently Low-Density Parity Check (LDPC) codes have 
gained in popularity. They are simple to construct, and can be 
efficiently decoded at error levels quite close to the theoretical 
limits.</p>

<p>With LDPC codes, there are three limits of interest for any given 
channel and design bitrate (M/N): 1) the error level upto which an 
algorithm can efficiently decode them, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_221.png" alt="\epsilon_d" title="\epsilon_d" class="latex">, 2) the error level level upto which they can be decoded by a computationally unbounded decoder, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_232.png" alt="\epsilon_c" title="\epsilon_c" class="latex"> and, 3) the error level beyond which <em>no </em>encoding scheme can achieve reliable communication, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_026.png" alt="\epsilon_s" title="\epsilon_s" class="latex">. Obviously, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_004.png" alt="\epsilon_d \le \epsilon_c \le \epsilon_s" title="\epsilon_d \le \epsilon_c \le \epsilon_s" class="latex">, and in general these inequalities can be strict. Our goal here is to study the gap between <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_221.png" alt="\epsilon_d" title="\epsilon_d" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_232.png" alt="\epsilon_c" title="\epsilon_c" class="latex">. We will sometimes refer to these three quantities as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex">, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex">, and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_134.png" alt="p_{shannon}" title="p_{shannon}" class="latex"> when discussing channels besides the BEC. This is following the notation of Mezard and Montanari (2009).</p>

<p>More formally, information theory concerns reliable communication via
 an unreliable channel. To mitigate the errors in message transmission, 
error correcting codes introduce some type of systematic redundancy in 
the transmitted message. Encoding maps are applied to the information 
sequence to get the encoded message that is transmitted through the 
channel. The decoding map, on the other hand, is applied to the noisy 
channel bit (see Figure below). Each message encoded is comprised of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_172.png" alt="M" title="M" class="latex"> bits and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_095.png" alt="N&gt;M" title="N&gt;M" class="latex"> redundant sequences of bits in an error correcting code. <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_074.png" alt="2^M" title="2^M" class="latex"> possible codewords form a “codebook” <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_144.png" alt="|\mathbb{C}|" title="|\mathbb{C}|" class="latex"> in binary space <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_103.png" alt="\{0,1\}" title="\{0,1\}" class="latex">.</p>

<p>Claude Shannon’s code ensembles proved that it is easier to construct
 stochastic (characterized by good properties and high probability) 
models vs. deterministic code designs. Stochastic models were able to 
achieve optimal error correcting code performance in comparison to a 
more rigidly constructed model, proving that it was possible to 
communicate with a vanishing error probability as long as the rate of 
transmission <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_072.png" alt="R=M/N" title="R=M/N" class="latex"> is smaller than the channel capacity, a measure of the maximum mutual information between channel input and output.</p>

<figure class="wp-block-image is-resized"><img loading="lazy" data-attachment-id="6366" data-permalink="https://windowsontheory.org/encodedecode/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/encodedecode.png" data-orig-size="297,170" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="encodedecode" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/encodedecode.png?w=297" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/encodedecode.png?w=297" class="wp-image-6366" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/encodedecode.png" alt="" srcset="https://windowsontheory.files.wordpress.com/2018/12/encodedecode.png 297w, https://windowsontheory.files.wordpress.com/2018/12/encodedecode.png?w=150&amp;h=86 150w" sizes="(max-width: 456px) 100vw, 456px" width="456" height="261"><figcaption><strong>Fig 1</strong> Schematic of the communication model of information communication.</figcaption></figure>

<p>Thus, in order to construct an optimal error correcting code, one 
must first define the subset of the space of encoding maps, endow the 
set with probability distributions, and subsequently define the 
associated decoding map for each of the encoding maps in the codes. We 
have included a section in the A that gives a thorough discussion of 
random code ensembles which are known to achieve optimal decoding, 
whether via scoring decoding success by bit error rate or decoded word 
error rate. We will also show a perspective which uses principles from 
statistical physics to unify the two (often called finite-temperature 
decoding). From hereon out we will discuss LDPC and explore how the 
values of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex">, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_134.png" alt="p_{shannon}" title="p_{shannon}" class="latex"> for various channels reveal deep things about the structure of the decoding solution space.</p>

<h3>Low-density Parity Check Code</h3>

<p>LDPC codes are linear and theoretically excellent error correcting 
codes that communicate at a rate close to the Shannon capacity. The LDPC
 codebook is a linear subspace of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_202.png" alt="\{0,1\}^N " title="\{0,1\}^N " class="latex">. For an MxN sparse matrix <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_045.png" alt="\mathbb{H}" title="\mathbb{H}" class="latex">, the codebook is defined as the kernel:</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_089.png" alt="\mathbb{C} = { \underline{x} \in \{0,1\}^N:\mathbb{H}\underline{x}=\underline{0}}" title="\mathbb{C} = { \underline{x} \in \{0,1\}^N:\mathbb{H}\underline{x}=\underline{0}}" class="latex"></p>

<p><br>where all the multiplications and sums involved in <br><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_046.png" alt="\mathbb{H} \underline{x} " title="\mathbb{H} \underline{x} " class="latex"> are computed modulo 2.</p>

<p>Matrix <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_045.png" alt="\mathbb{H}" title="\mathbb{H}" class="latex">is called the <strong>parity check matrix</strong> and the size of the codebook is <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_218.png" alt="2^{N-rank(\mathbb{H})}" title="2^{N-rank(\mathbb{H})}" class="latex">. Given this code, encoding is a linear operation when mapping an <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_233.png" alt="N x L" title="N x L" class="latex"> binary generating matrix <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_054.png" alt="\mathbb{G}" title="\mathbb{G}" class="latex"> (the codebook is the image of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_108.png" alt="\mathbb{G}:\mathbb{C}={x=\mathbb{G}\underline{z}, \text{where } \underline{z} \in \{0,1\}^L} " title="\mathbb{G}:\mathbb{C}={x=\mathbb{G}\underline{z}, \text{where } \underline{z} \in \{0,1\}^L} " class="latex">) such that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_066.png" alt="\underline{z}\rightarrow \underline{x} =\mathbb{G}z" title="\underline{z}\rightarrow \underline{x} =\mathbb{G}z" class="latex">).</p>

<p>Every coding scheme has three essential properties that determine its
 utility: the geometry of its codebook and the way it sparsely 
distributes proper codewords within the encoding space <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_143.png" alt="\{0,1\}^{N}" title="\{0,1\}^{N}" class="latex"> (c.f. our mention of sphere packing as a geometric analogy for RLCs), the ease with which one can <em>construct a code</em> which sparsely distributes codes within the encoding space, and the existence of fast algorithms to perform effective decoding.</p>

<p>A coding scheme over a given channel (whether it be <a href="https://en.wikipedia.org/wiki/Binary_symmetric_channel">BSC</a>, <a href="https://en.wikipedia.org/wiki/Binary_erasure_channel">BEC</a>, <a href="https://en.wikipedia.org/wiki/Additive_white_Gaussian_noise">AWGN</a>, etc.) also has three parameters of interest, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_081.png" alt="p_{d} " title="p_{d} " class="latex"> which is the error rate above which some chosen algorithm cannot perform error-free decoding, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"> above which even exhaustively enumerating over all <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_010.png" alt="2^{M}" title="2^{M}" class="latex"> codewords in the codebook and calculating the MAP probability does not successfully decode, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_134.png" alt="p_{shannon}" title="p_{shannon}" class="latex"> which is the capacity of the channel, an error rate above which no decoding scheme could perform error-free decoding.</p>

<h4>LDPC codebook geometry and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"></h4>

<p>On the subject of codebook geometry, it is well known that LDPC 
ensembles, in expectation, produce sparsely distributed codewords. This 
means that valid codewords (i.e. those that pass all parity checks) are 
far apart from one another in Hamming space and thus require a 
relatively large number of bits to be lost in order for one codeword to 
degenerate into another one. There is an important property called the 
distance enumerator which determines the expected number of codewords in
 a tight neighborhood of any given codeword. If for a given distance the
 expected number is exponentially small, then the coding scheme is 
robust up to error rates causing that degree of distortion. We discuss a
 proof of LDPC distance properties in Appendix B and simply state here 
that LDPCs are good at sparsely distributing valid codewords within the 
encoding space. The property <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex">,
 introduced above is intimately related to the geometry of the codebook 
and the properties of the noisy channel being decoded over.</p>

<p>The information theoretic threshold, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"> is the noise level above which MAP decoding no longer successfully performs decoding. <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"> is important because it is the error value above which we could theoretically always perform (slow) decoding below <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"> by enumerating all <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_010.png" alt="2^{M}" title="2^{M}" class="latex"> codewords in the codebook and calculating the one with the highest MAP probability.</p>

<p>Every LDPC ensemble has some different <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"> for a given channel. WFor now we will simply remark that LDPC ensembles are effective because they can be chosen such that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"> closely approaches the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_134.png" alt="p_{shannon}" title="p_{shannon}" class="latex"> limit for many channels. Even more importantly, we will show that it is <em>likely </em>that there is no fast algorithm for which <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex"> = <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"> for general LDPCs over a general noisy channel.</p>

<p>We will not derive the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"> for any LDPC ensembles over any channels (I recommend <a href="https://web.stanford.edu/~montanar/RESEARCH/book.html">chapter 15 of this book for details</a>), but we will, in section 3, present results derived by other researchers.</p>

<h4>Ease of construction</h4>

<p>On the subject of ease of construction and ease of decoding, there is
 a much simpler graphical representation of LDPC codes which can be used
 to demonstrate LDPC tractability.</p>

<p>LDPCs can be thought of as bipartite regular graphs, where there are N
 variable nodes which are connected to M parity check nodes according to
 randomly chosen edges based on the degree distribution of the LDPC. 
Though the appendix discusses general degree distributions we will 
discuss here only (d,k) regular bipartite graphs, in which all variables
 have d edges and all parity check nodes have k edges, and how to 
generate them under the configuration model.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Configuration_model">configuration model</a>&nbsp;can
 be used to generate a bipartite graph with (d,k) degree distribution by
 initially assigning all variable nodes d half-edges, all parity check 
nodes k half-edges, and then randomly linking up half-edges between the 
two sets, deleting all nodes which end up being paired an even number of
 times, and collapsing all odd numbered multi-edges into a single edge. 
This system doesn’t work perfectly but for large N, the configuration 
model will generate a graph for which most nodes have the proper degree.
 Thus it is relatively easy to generate random graphs which represent 
LDPC codes of any desired uniform degree distribution. An example of 
this graphical representation is in figure 2</p>

<figure class="wp-block-image"><img data-attachment-id="6382" data-permalink="https://windowsontheory.org/graph-2/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/graph.png" data-orig-size="872,368" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="graph" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/graph.png?w=300" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/graph.png?w=656" class="wp-image-6382" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/graph.png" alt=""><figcaption><strong>Fig 2 </strong>Factor
 graph of a (2,3) regular LDPC code with factor nodes as black squares 
and variable nodes as white circles, and notation for BP messages.</figcaption></figure>

<h2>How the graphical model relates to fast decoding</h2>

<p>The graphical model of LDPCs is useful because it is both easy to 
construct and presents a natural way to perform fast decoding. In fact, 
the fast graph-based decoding algorithm, <a href="http://{https//en.wikipedia.org/wiki/Belief_propagation">Belief Propagation</a>, we use has a <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex"> which likely represents the upper limit on fast decoding for LDPCs.</p>

<p>We have seen <a href="https://windowsontheory.org/2018/10/20/belief-propagation-and-the-stochastic-block-model/">recently </a>that bipartite graphical models <br>which
 represent a factorized probability distribution can be used to 
calculate marginal probabilities of individual variable nodes (what a 
mouthful!).</p>

<p>Basically, if the structure of the graph reflects some underlying probability distribution (e.g. the probability that noisy bit <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_131.png" alt="y_i" title="y_i" class="latex"> was originally sent as bit <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_137.png" alt="x_i" title="x_i" class="latex">)
 then we can use an iterative algorithm called Belief Propagation (see 
blog post above) to actually converge to the exact probability 
distribution for each <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_189.png" alt="P(y_i~|~x_{i})" title="P(y_i~|~x_{i})" class="latex">.</p>

<p>This is important because when we perform decoding, we would like to 
estimate the marginal probability of each individual variable node (bit 
in our received vector), and simply set the variable to be the most 
likely value (this is known as bit-MAP decoding, discussed earlier). As 
mentioned above, under certain conditions the Belief Propagation 
algorithm correctly calculates those marginal probabilities for noise 
rates up to an algorithmic threshold <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex">.</p>

<p>The Belief Propagation algorithm is an iterative message passing 
algorithm in which messages are passed between variable nodes and parity
 check/factor nodes such that, if the messages converge to a fixed 
point, the messages encode the marginal probabilities of each variable 
node. Thus BP, if it succeeds can perform bit-MAP decoding and thus 
successfully decode.</p>

<p>We will show in the next section how the configuration model graphs 
map to a factorized probability distribution and mention the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex">
 for BP. In the following section we will show an example of decoding 
over the binary erasure channel, then finally we will show motivation to
 suggest that the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex"> for BP over LDPCs represents a hard upper limit above which no fast decoding algorithms exist.</p>

<h3>Decoding Errors via Belief Propagation</h3>

<p>As mentioned above (<a href="https://windowsontheory.org/2018/10/20/belief-propagation-and-the-stochastic-block-model/">again, please see Tom’s excellent blog post for details</a>),
 the belief propagation algorithm is a useful inference algorithm for 
stochastic models and sparse graphs derived from computational problems 
exhibiting thresholding behavior. As discussed, symbol/bit MAP decoding 
of error correcting codes can be regarded as a statistical inference 
problem. In this section, we will explore BP decoding to determine the 
threshold for reliable communication and according optimization for LDPC
 code ensembles in communication over a binary input output symmetric 
memoryless channel (BSC or BMS).</p>

<h4>Algorithm Overview</h4>

<p>Recall that the conditional distribution of the channel input <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_240.png" alt="\underline{x}" title="\underline{x}" class="latex"> given the output <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_003.png" alt="\underline{y}" title="\underline{y}" class="latex"> is given by and that we wish to find the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_240.png" alt="\underline{x}" title="\underline{x}" class="latex"> that maximizes the below probability given <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_003.png" alt="\underline{y}" title="\underline{y}" class="latex"></p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_112.png" alt="p(\underline{x}|\underline{y}) = \frac{1}{Z(y)}\prod_{i=1}^{N}Q(y_i|x_i) \prod_{a=1}^{M} \mathbb{I}(x_{i_{1^{a}}}&nbsp;\otimes ... ~x_{k(a)^a} = 0)" title="p(\underline{x}|\underline{y}) = \frac{1}{Z(y)}\prod_{i=1}^{N}Q(y_i|x_i) \prod_{a=1}^{M} \mathbb{I}(x_{i_{1^{a}}}&nbsp;\otimes ... ~x_{k(a)^a} = 0)" class="latex"> (1)</p>

<p style="text-align:left;"><br>Where <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_178.png" alt="Q(y_i~|~x_{i})" title="Q(y_i~|~x_{i})" class="latex"> is the conditional probability of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_150.png" alt="y_{i}" title="y_{i}" class="latex"> of observing noisy bit <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_150.png" alt="y_{i}" title="y_{i}" class="latex"> given that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_167.png" alt="x_{i}" title="x_{i}" class="latex"> was sent. For the BSC we have <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_016.png" alt="Q(y_{i} = 1 | x_{i} = 1) = Q(y_{i} = 0 | x_{i} = 0) = 1-p" title="Q(y_{i} = 1 | x_{i} = 1) = Q(y_{i} = 0 | x_{i} = 0) = 1-p" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_069.png" alt="Q(y_{i} = 1 | x_{i} = 0) = Q(y_{i} = 0 | x_{i} = 1) = p" title="Q(y_{i} = 1 | x_{i} = 0) = Q(y_{i} = 0 | x_{i} = 1) = p" class="latex">.</p>

<p>Furthermore</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_025.png" alt="\mathbb{I} (x_{i_{1^{a}}}&nbsp;\otimes&nbsp; ... ~x_{k(a)^a} = 0)" title="\mathbb{I} (x_{i_{1^{a}}}&nbsp;\otimes&nbsp; ... ~x_{k(a)^a} = 0)" class="latex"></p>

<p>is an indicator variable which takes value <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_159.png" alt="1" title="1" class="latex"> if <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_240.png" alt="\underline{x}" title="\underline{x}" class="latex">
 satisfies parity check a and 0 otherwise. In particular, the product of
 these indicators takes into account the fact that 0 probability should 
be assigned to hypotheses <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_240.png" alt="\underline{x}" title="\underline{x}" class="latex"> which aren’t in the code book (indicated by at least one parity check failing).</p>

<p>We would like to design a message passing scheme such that the 
incoming messages for a given variable node encode their marginal 
probabilities <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_011.png" alt="p(x_i~|~y_i)" title="p(x_i~|~y_i)" class="latex">.</p>

<p>Note, first and foremost that this probability can be <em>factorized </em>a la BP factor graphs such that there is a factor node for each parity check node <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_176.png" alt="a" title="a" class="latex"> which contributes probability</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_179.png" alt="\mathbb{I} (x_{i_{1^{a}}}&nbsp;\otimes ... ~x_{k(a)^a} = 0)" title="\mathbb{I} (x_{i_{1^{a}}}&nbsp;\otimes ... ~x_{k(a)^a} = 0)" class="latex"></p>

<p>and a factor node for each channel probability term <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_178.png" alt="Q(y_i~|~x_{i})" title="Q(y_i~|~x_{i})" class="latex">.
 Since each channel probability term is only connected to a single 
variable, its message never gets updated during BP and so we omit it 
from the factor graphs (e.g. note that figure 2 only has parity check 
nodes and variable nodes)</p>

<p>The message passing scheme ends up taking the form</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_170.png" alt="v_{i\rightarrow a}^{(t+1)}(x_i) \propto Q(y_{i} | x_{i}) \prod_{b \in \partial i \setminus a} \hat{v}{b \rightarrow i}^{(t)}" title="v_{i\rightarrow a}^{(t+1)}(x_i) \propto Q(y_{i} | x_{i}) \prod_{b \in \partial i \setminus a} \hat{v}{b \rightarrow i}^{(t)}" class="latex"> (2)</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_050.png" alt="\hat{v}_{a \rightarrow i}(x_{i}) \propto \sum_{{x_{j}}} \mathbb{I} (x_{i} \otimes x_{j_{1}} ... x_{j_{k-1}} = 0) \prod_{j \in \partial a \setminus i} v_{j\rightarrow a}^{(t)}(x_j)" title="\hat{v}_{a \rightarrow i}(x_{i}) \propto \sum_{{x_{j}}} \mathbb{I} (x_{i} \otimes x_{j_{1}} ... x_{j_{k-1}} = 0) \prod_{j \in \partial a \setminus i} v_{j\rightarrow a}^{(t)}(x_j)" class="latex"> (3)</p>

<p>Where <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_206.png" alt="\partial a" title="\partial a" class="latex"> denotes the neighborhood of factor node <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_176.png" alt="a" title="a" class="latex"> and the sum in (3) is over all possible configurations of the neighbors of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_176.png" alt="a" title="a" class="latex"> not including <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_243.png" alt="i" title="i" class="latex">.</p>

<p>Messages are passed along the edges as distributions over binary valued variables described by the log-likelihoods</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_014.png" alt="h_{i\rightarrow a} = \frac{1}{2}\log \frac{v_{i\rightarrow a(0)}}{v_{i\rightarrow a (1)}}" title="h_{i\rightarrow a} = \frac{1}{2}\log \frac{v_{i\rightarrow a(0)}}{v_{i\rightarrow a (1)}}" class="latex"> (4)</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_039.png" alt="u_{i\rightarrow a} = \frac{1}{2}\log \frac{\hat{v}{i\rightarrow a(0)}}{\hat{v}{i\rightarrow a (1)}}" title="u_{i\rightarrow a} = \frac{1}{2}\log \frac{\hat{v}{i\rightarrow a(0)}}{\hat{v}{i\rightarrow a (1)}}" class="latex"> (5)</p>

<p><br>We also introduce the a priori log likelihood for bit <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_243.png" alt="i" title="i" class="latex"> given the received message <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_131.png" alt="y_i" title="y_i" class="latex">:</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_092.png" alt="B_{i} = \frac{1}{2} log \frac{Q(y_{i} | 0)}{Q(y_{i} | 1)}" title="B_{i} = \frac{1}{2} log \frac{Q(y_{i} | 0)}{Q(y_{i} | 1)}" class="latex"></p>

<p>Once we parametrize the messages as log-likelihoods, it turns out we 
can rewrite our update rules in terms of the parametrized values h and 
u, making updates much simpler:</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_038.png" alt="h_{i \rightarrow a}^{(t+1)} = B_i + \sum_{b \in \partial i \setminus a} u_{b \rightarrow i}^{(t)}" title="h_{i \rightarrow a}^{(t+1)} = B_i + \sum_{b \in \partial i \setminus a} u_{b \rightarrow i}^{(t)}" class="latex"> (6)</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_229.png" alt="u_{b\rightarrow i}^{(t)} = atanh{ \prod_{j \in \partial a \setminus i} tanh(h_{j \rightarrow a}^{(t)})}" title="u_{b\rightarrow i}^{(t)} = atanh{ \prod_{j \in \partial a \setminus i} tanh(h_{j \rightarrow a}^{(t)})}" class="latex"> (7)</p>

<p>Given a set of messages, we would perform decoding via the overall log likelihood <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_064.png" alt="h_{i}^{(t+1)} = B_i + \sum_{b \in \partial i} u_{b \rightarrow i}^{(t)}" title="h_{i}^{(t+1)} = B_i + \sum_{b \in \partial i} u_{b \rightarrow i}^{(t)}" class="latex">. Where <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_167.png" alt="x_{i}" title="x_{i}" class="latex"> gets decoded to 0 for <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_088.png" alt="h_{i} &gt; 0" title="h_{i} &gt; 0" class="latex"> and 1 for <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_227.png" alt="h_{i} &lt; 0" title="h_{i} &lt; 0" class="latex">.</p>

<p>Typically BP is run until it converges to a set of messages that 
decode to a word in the codebook, or until a max number of iterations 
have occurred. Other stopping criteria exist such as the messages 
between time step t and t+1 being all within some small <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_168.png" alt="\epsilon" title="\epsilon" class="latex"> of one another.</p>

<p>It is important to note some properties of BP:</p>

<ol><li><strong>BP always terminates in <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_063.png" alt="d" title="d" class="latex"> steps if the factor graph is a tree of depth <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_063.png" alt="d" title="d" class="latex"></strong></li><li><strong>It is not known under what circumstances so called “loopy” BP will converge for non-tree graphs</strong></li></ol>

<p>Because factor graphs of LDPC codes are relatively sparse, they 
appear “locally tree-like”, a property which is believed to play a 
crucial role in BP convergence over the factorized probability 
distribution used in LDPC MAP decoding (eqn 1). As mentioned above BP 
manages to converge on many sorts of non tree-like graphs given that 
they have “nice” probability distributions. For example <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=2ahUKEwic8ozUqoTfAhXLxlkKHWKGDfYQFjABegQICBAC&amp;url=https%3A%2F%2Fstatweb.stanford.edu%2F~souravc%2Ftalk_spin.pdf&amp;usg=AOvVaw0LixaqHUkY6G795LkiyEgX">the SK model</a> is known to converge even though the underlying factor graph is a complete graph!</p>

<p>It turns out that BP converges under some noise levels for LDPC decoding, and that the threshold at which it fails to converge, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex">,
 represents a phase transition to a generically different regime in the 
solution space of the codebook. It’s been noted elsewhere that the BP 
threshold is often the threshold of fast solving for many cool problems;
 e.g. <a href="https://www.amazon.com/Nature-Computation-Cristopher-Moore/dp/0199233217">k-SAT</a>.
 This is because it is often thought to generically represent the “best”
 possible local (ergo “fast”) algorithm for those problems</p>

<p>In appendix C we will show some important properties of BP. The 
following tables summarize important results for several ensembles and 
channels. Note how close the information theoretic threshold for LDPCs 
is to the actual shannon limit <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_134.png" alt="p_{shannon}" title="p_{shannon}" class="latex"> for the channels below.</p>

<p style="text-align:center;"><strong>Table 1</strong>: Thresholds for BSC<br>Various thresholds for BP over LDPC codes in a Binary Symmetric Channel</p>

<table class="wp-block-table has-fixed-layout is-style-stripes"><tbody><tr><td>d</td><td>k</td><td><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex"></td><td><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"></td><td>Shannon limit</td></tr><tr><td>3</td><td>4</td><td>.1669</td><td>.2101</td><td>.2145</td></tr><tr><td>3</td><td>5</td><td>.1138</td><td>.1384</td><td>.1461</td></tr><tr><td>3</td><td>6</td><td>.084</td><td>.101</td><td>.11</td></tr><tr><td>4</td><td>6</td><td>.1169</td><td>.1726</td><td>.174</td></tr></tbody></table>

<p style="text-align:center;">See Mezard and Montanari, 2009 Chapt 15. for this table</p>

<p style="text-align:center;"><strong>Table 2</strong>: Thresholds for BEC<br>Various thresholds for BP over LDPC codes in a Binary Erasure Channel</p>

<table class="wp-block-table has-fixed-layout is-style-stripes"><tbody><tr><td>d</td><td>k</td><td><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_102.png" alt="\epsilon_{d}" title="\epsilon_{d}" class="latex"></td><td><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_223.png" alt="\epsilon_{c}" title="\epsilon_{c}" class="latex"></td><td>Shannon limit</td></tr><tr><td>3</td><td>4</td><td>.65</td><td>.746</td><td>.75</td></tr><tr><td>3</td><td>5</td><td>.52</td><td>.59</td><td>.6</td></tr><tr><td>3</td><td>6</td><td>.429</td><td>.4882</td><td>.5</td></tr><tr><td>4</td><td>6</td><td>.506</td><td>.66566</td><td>.6667</td></tr></tbody></table>

<p style="text-align:center;">See Mezard and Montanari, 2009 Chapt 15. for this table</p>

<p>We will now show exact behavior of the (3,6) LDPC ensemble over the binary erasure channel.</p>

<h3>Algorithmic Thresholds for Belief Propagation (BP)</h3>

<h4>Definitions and notation</h4>

<p><strong>Definition 1.</strong> In a <strong>Binary Erasure Channel (BEC)</strong>, when the transmitter sends a bit <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_135.png" alt="\in {0, 1}" title="\in {0, 1}" class="latex">, the receiver receives the correct bit with probability <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_182.png" alt="1 - \epsilon" title="1 - \epsilon" class="latex"> or an error symbol <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_031.png" alt="*" title="*" class="latex"> with probability <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_168.png" alt="\epsilon" title="\epsilon" class="latex">.</p>

<p>For BECs, the Shannon capacity—the maximum number of data bits that can be transmitted per encoded bit—is given by <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_182.png" alt="1 - \epsilon" title="1 - \epsilon" class="latex">.</p>

<p><strong>Definition 2.</strong> An <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_211.png" alt="N" title="N" class="latex">-bit <strong>Error Correcting Code (ECC)</strong>&nbsp;is defined by a codebook <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_217.png" alt="\mathcal{C} \subset {0, 1}^N" title="\mathcal{C} \subset {0, 1}^N" class="latex">. The transmitter encodes information as an element of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_111.png" alt="\mathcal{C}" title="\mathcal{C}" class="latex">. The receiver receives a corrupted version <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_065.png" alt="y" title="y" class="latex"> of the transmitted codeword. To decode, it picks an <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_183.png" alt="x \in \mathcal{C}" title="x \in \mathcal{C}" class="latex"> that is most likely given <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_065.png" alt="y" title="y" class="latex"> and the channel characteristics.</p>

<p>For ease of discourse, we have refrained from defining ECC in full generality.</p>

<p><strong>Definition 3.</strong> An <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_211.png" alt="N" title="N" class="latex">-bit <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_219.png" alt="(\lambda, \rho)" title="(\lambda, \rho)" class="latex"> Low Density Parity Check Code (LDPC) is an ECC with <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_141.png" alt="\mathcal{C} = {x | Hx = 0}" title="\mathcal{C} = {x | Hx = 0}" class="latex">. Here <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_213.png" alt="H" title="H" class="latex"> is an <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_047.png" alt="M \times N" title="M \times N" class="latex"> matrix and arithmetic is over <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_097.png" alt="\mathbb{Z}_2" title="\mathbb{Z}_2" class="latex">. <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_213.png" alt="H" title="H" class="latex"> is a sparse parity-check matrix. <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_062.png" alt="\lambda(x) = \sum_i\lambda_ix^{i-1}" title="\lambda(x) = \sum_i\lambda_ix^{i-1}" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_027.png" alt="\rho(x) = \sum_i\rho_ix^{i-1}" title="\rho(x) = \sum_i\rho_ix^{i-1}" class="latex"> are finite polynomials that characterize <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_213.png" alt="H" title="H" class="latex">; <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_192.png" alt="\lambda_i" title="\lambda_i" class="latex"> is the fraction of columns with <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_243.png" alt="i" title="i" class="latex"> <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_159.png" alt="1" title="1" class="latex">s and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_083.png" alt="\rho_i" title="\rho_i" class="latex"> is the fraction of rows with <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_243.png" alt="i" title="i" class="latex"> <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_159.png" alt="1" title="1" class="latex">s. Since these are fractions/probabilities, they must be normalized. Hence <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_173.png" alt="\lambda(1) = \rho(1) = 1" title="\lambda(1) = \rho(1) = 1" class="latex">. <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_213.png" alt="H" title="H" class="latex"> is a random matrix, and therefore has full rank with high probability.</p>

<p>In an LDPC code, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_241.png" alt="|\mathcal{C}| = 2^{N - M}" title="|\mathcal{C}| = 2^{N - M}" class="latex">. Hence every <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_211.png" alt="N" title="N" class="latex"> bits contain <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_020.png" alt="N-M" title="N-M" class="latex"> bits of information, making the rate <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_080.png" alt="1 - M / N" title="1 - M / N" class="latex">. Over binary erasure channels (BECs), on receiving <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_065.png" alt="y" title="y" class="latex">, the decoder must choose an <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_187.png" alt="x" title="x" class="latex"> such that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_244.png" alt="x_i = y_i \forall i" title="x_i = y_i \forall i" class="latex"> such that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_121.png" alt="y_i \neq *" title="y_i \neq *" class="latex">, and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_119.png" alt="Hx = 0" title="Hx = 0" class="latex"> (<img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_137.png" alt="x_i" title="x_i" class="latex">, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_131.png" alt="y_i" title="y_i" class="latex"> denote the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_005.png" alt="i^{th}" title="i^{th}" class="latex"> bit of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_187.png" alt="x" title="x" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_065.png" alt="y" title="y" class="latex">
 respectively). That is, the bits that were successfully transmitted 
should be preserved; other bits should be chosen to satisfy the parity 
check equations. If multiple correct choices of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_187.png" alt="x" title="x" class="latex"> are possible, then <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_065.png" alt="y" title="y" class="latex"> cannot be unambiguously decoded.</p>

<h4>BP/Peeling algorithm</h4>

<p>In general, decoding can be computationally hard. But there exists an error rate <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_221.png" alt="\epsilon_d" title="\epsilon_d" class="latex">, a function of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_200.png" alt="\lambda" title="\lambda" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_075.png" alt="\rho" title="\rho" class="latex">, below which belief propagation succeeds in decoding. Let <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_232.png" alt="\epsilon_c" title="\epsilon_c" class="latex">
 be the maximum error rate upto which successful decoding is possible 
(i.e. we can unambiguously determine the transmitted codeword) and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_026.png" alt="\epsilon_s" title="\epsilon_s" class="latex"> be the Shannon limit, then <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_073.png" alt="\epsilon_d \leq \epsilon_c \leq \epsilon_s" title="\epsilon_d \leq \epsilon_c \leq \epsilon_s" class="latex">.
 In general, these inequalities can be strict, illustrating the gap 
between what is information theoretically possible, and what is 
computationally feasible.</p>

<p>Belief propagation (BP) for decoding LDPC-codes is equivalent to a 
simple peeling algorithm. Let us first describe the factor-graph 
representation for decoding. This is denoted in figure 3. Variables on 
the left are the received symbol <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_235.png" alt="\in {0, 1, *}" title="\in {0, 1, *}" class="latex">. Factor nodes on the right denote the parity-check constraint (rows of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_213.png" alt="H" title="H" class="latex">). The XOR of variables connected to each factor node must be 0.</p>

<p>BP/the peeling algorithm works as follows. For simplicity of 
exposition, consider that the all zeros code-word has been transmitted. 
Since this is a linear code, there is no loss of generality. At first, 
only the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_182.png" alt="1 - \epsilon" title="1 - \epsilon" class="latex">
 variables that were successfully transmitted are fully determined. In 
the next round, the factor nodes that have exactly one undetermined 
variable can determine that variable using their parity-check 
constraint.</p>

<figure class="wp-block-image"><img data-attachment-id="6433" data-permalink="https://windowsontheory.org/bp-fails/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/bp-fails.png" data-orig-size="508,651" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bp-fails" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/bp-fails.png?w=234" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/bp-fails.png?w=508" class="wp-image-6433" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/bp-fails.png" alt=""><figcaption><strong>Fig 3</strong>
 An example of a received code-word and corresponding parity-check 
constraints that is information-theoretically determined (only the all 
zeros codeword satisfies all constraints), but cannot be decoded by the 
belief propagation algorithm because no factor node has exactly one 
unknown variable. Here, only the V0 is correctly received. Constraints 
F1, F2, F3 and F4 imply that V1=V2=V3=V4=V5. If V0=0, then all the rest 
must be 0s to satisfy F0 (note, the only other valid codeword is all 
ones).</figcaption></figure>

<h4>BP isn’t perfect</h4>

<p>This algorithm is not perfect. Figure 3 is an example of a received codeword which <em>can </em>be
 unambiguously decoded — only the all zeros codeword satisfies all the 
constraints— but the BP algorithm fails, because at any point, all 
factor nodes have more than one unknown variable. It seems that the only
 way to solve problems like that is to exhaustively understand the 
implications of the parity-check equations. If this examples seems 
contrived, that is because it is. Decoding becomes harder as the degree 
and number of constraints increases; we had to add a lot of constraints 
to make this example work. Fortunately, if the graph is sparse, BP 
succeeds. We prove this in the following theorem:</p>

<h4>Phase transitions for BP</h4>

<p><strong>Theorem 1.</strong> A <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_219.png" alt="(\lambda, \rho)" title="(\lambda, \rho)" class="latex"> LDPC code can be decoded by BP as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_007.png" alt="N \rightarrow \infty" title="N \rightarrow \infty" class="latex"> when the error rate is less than <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_221.png" alt="\epsilon_d" title="\epsilon_d" class="latex">:</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_068.png" alt="\epsilon_d = \mathrm{inf}_{z \in (0, 1)}\left[\frac{z}{\lambda(1 - \rho(1 - z))}\right]" title="\epsilon_d = \mathrm{inf}_{z \in (0, 1)}\left[\frac{z}{\lambda(1 - \rho(1 - z))}\right]" class="latex"></p>

<p><em>Proof.</em>&nbsp;To prove this, let us analyze the density 
evolution. For BECs, this is particularly simple as we only need to keep
 track of the fraction of undetermined variables and factor nodes at 
timestep <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_214.png" alt="t:~latex z_t" title="t:~latex z_t" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_041.png" alt="\hat{z}_t" title="\hat{z}_t" class="latex"> respectively. As <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_007.png" alt="N \rightarrow \infty" title="N \rightarrow \infty" class="latex">,
 these fractions are probabilities. A factor node is determined when all
 of its variables are determined (note: if all but one is determined, 
the last one can be immediately determined). The following recursion 
relations hold:</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_093.png" alt="z_{t+1} = \epsilon\lambda(\hat{z}_t) \:\:\:\mathrm{and}\:\:\: \hat{z}_t = 1 - \rho(1 - z_t)" title="z_{t+1} = \epsilon\lambda(\hat{z}_t) \:\:\:\mathrm{and}\:\:\: \hat{z}_t = 1 - \rho(1 - z_t)" class="latex"> (8)</p>

<p>The first holds because a variable node is undetermined at timestep <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_242.png" alt="t+1" title="t+1" class="latex"> if it was originally undetermined (which happens with probability <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_168.png" alt="\epsilon" title="\epsilon" class="latex">) <em>and </em>if it isn’t determined in the last step, which happens with probability say <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_239.png" alt="p" title="p" class="latex">. Now,</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_012.png" alt="p = \mathbf{P}(degree=2)\hat{z}_t + \mathbf{P}(degree=3)\hat{z}_t^2 + \cdots = \lambda(\hat{z}_t)" title="p = \mathbf{P}(degree=2)\hat{z}_t + \mathbf{P}(degree=3)\hat{z}_t^2 + \cdots = \lambda(\hat{z}_t)" class="latex"></p>

<p>A similar reasoning holds for the second relation. <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_147.png" alt="1 - z_t" title="1 - z_t" class="latex"> is the probability that a given neighboring variable node is determined. <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_042.png" alt="\rho(1 - z_t)" title="\rho(1 - z_t)" class="latex"> is the probability that at-most one is undetermined, and hence this function node is determined. <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_087.png" alt="1 - \rho(1 - z_t)" title="1 - \rho(1 - z_t)" class="latex"> is the probability that this function node is undetermined.</p>

<p>Composing the two relations in equation 8, we get the recursion:</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_191.png" alt="z_{t+1} = F_{\epsilon}(z) = \epsilon \lambda(1 - \rho(1 - z_t))" title="z_{t+1} = F_{\epsilon}(z) = \epsilon \lambda(1 - \rho(1 - z_t))" class="latex"></p>

<p>An example of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_190.png" alt="F(z)" title="F(z)" class="latex"> is shown in Figure 4 for <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_130.png" alt="\lambda(x) = x^2, \rho(x) = x^5" title="\lambda(x) = x^2, \rho(x) = x^5" class="latex">. That is a (3,6) regular graph where variable nodes and function nodes have 3 and 6 neighbors respectively. On the left, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_190.png" alt="F(z)" title="F(z)" class="latex"> is always below <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_084.png" alt="z" title="z" class="latex">. Hence the recursion with <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_094.png" alt="z_0" title="z_0" class="latex"> starting from the far right will converge to the fixed point <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_106.png" alt="F(z) = z = 0" title="F(z) = z = 0" class="latex">. But on the right, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_168.png" alt="\epsilon" title="\epsilon" class="latex"> is large enough that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_190.png" alt="F(z)" title="F(z)" class="latex"> intersects <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_084.png" alt="z" title="z" class="latex">
 at a non-zero point. Hence the recursion will converge to the higher 
fixed point instead, without ever reaching the `correct’ fixed point. BP
 therefore gets stuck at a suboptimal solution, though 
information-theoretically a correct solution exists. This can be 
interpreted as a glassy state, where many deep local minima are present,
 and BP will converge to the wrong minimum.</p>

<p>The condition for BP to converge is <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_049.png" alt="F_\epsilon(z) \le z \:\: \forall z \in (0, 1)" title="F_\epsilon(z) \le z \:\: \forall z \in (0, 1)" class="latex">. Hence the threshold error rate, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_221.png" alt="\epsilon_d" title="\epsilon_d" class="latex">, below which this condition holds is:</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_068.png" alt="\epsilon_d = \mathrm{inf}_{z \in (0, 1)}\left[\frac{z}{\lambda(1 - \rho(1 - z))}\right]" title="\epsilon_d = \mathrm{inf}_{z \in (0, 1)}\left[\frac{z}{\lambda(1 - \rho(1 - z))}\right]" class="latex"></p>

<p>For (3, 6) regular graphs, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_091.png" alt="\epsilon_d \approx 0.429" title="\epsilon_d \approx 0.429" class="latex">&nbsp;∎</p>

<figure class="wp-block-image is-resized"><img loading="lazy" data-attachment-id="6442" data-permalink="https://windowsontheory.org/ldpc-3-6-above/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-above.png" data-orig-size="1000,639" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ldpc-3-6-above" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-above.png?w=300" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-above.png?w=656" class="wp-image-6442" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/ldpc-3-6-above.png" alt="" srcset="https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-above.png?w=460&amp;h=293 460w, https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-above.png?w=917&amp;h=586 917w, https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-above.png?w=150&amp;h=96 150w, https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-above.png?w=300&amp;h=192 300w, https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-above.png?w=768&amp;h=491 768w" sizes="(max-width: 460px) 100vw, 460px" width="460" height="293"></figure>

<figure class="wp-block-image is-resized"><img loading="lazy" data-attachment-id="6443" data-permalink="https://windowsontheory.org/ldpc-3-6-below/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-below.png" data-orig-size="1000,639" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ldpc-3-6-below" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-below.png?w=300" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-below.png?w=656" class="wp-image-6443" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/ldpc-3-6-below.png" alt="" srcset="https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-below.png?w=463&amp;h=295 463w, https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-below.png?w=923&amp;h=590 923w, https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-below.png?w=150&amp;h=96 150w, https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-below.png?w=300&amp;h=192 300w, https://windowsontheory.files.wordpress.com/2018/12/ldpc-3-6-below.png?w=768&amp;h=491 768w" sizes="(max-width: 463px) 100vw, 463px" width="463" height="295"><figcaption><br><strong>Fig 4</strong>&nbsp;The recursion relation for a (3,6) regular graph, where <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_051.png" alt="F_\epsilon(z)" title="F_\epsilon(z)" class="latex"> is plotted against <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_084.png" alt="z" title="z" class="latex">. The identity function <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_084.png" alt="z" title="z" class="latex"> is also shown (in blue). Here <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_205.png" alt="\epsilon_d \approx0.429" title="\epsilon_d \approx0.429" class="latex">. The graph above and below show the case the error rate is below and above <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_221.png" alt="\epsilon_d" title="\epsilon_d" class="latex"> respectively.</figcaption></figure>

<p>Another interesting phase transition can be observed. As <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_168.png" alt="\epsilon" title="\epsilon" class="latex"> increases, for some values of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_219.png" alt="(\lambda, \rho)" title="(\lambda, \rho)" class="latex">, the first intersection of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_190.png" alt="F(z)" title="F(z)" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_190.png" alt="F(z)" title="F(z)" class="latex"> happens at a non-zero point. For others, it starts of at <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_156.png" alt="z=0" title="z=0" class="latex"> and goes up continuously. In the former case, the decoding error rate jumps discontinuously as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_168.png" alt="\epsilon" title="\epsilon" class="latex"> increases from 0 to a non-zero values. For the latter, it increases continuously.</p>

<p>To see the gap between <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_221.png" alt="\epsilon_d" title="\epsilon_d" class="latex">
 and what can be information theoretically, we look at what happens when
 the degrees of the LDPC code is increased while keeping the rate 
constant. Specifically consider the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_164.png" alt="(l, k)" title="(l, k)" class="latex"> regular graph (i.e. <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_107.png" alt="\lambda(x) = x^{l-1}" title="\lambda(x) = x^{l-1}" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_153.png" alt="\rho(x) = x^{k-1}" title="\rho(x) = x^{k-1}" class="latex">) as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_231.png" alt="k \rightarrow \infty" title="k \rightarrow \infty" class="latex"> while <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_184.png" alt="l / k = 0.5" title="l / k = 0.5" class="latex"> is fixed. Note that the rate of the code is <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_044.png" alt="1 - l / k" title="1 - l / k" class="latex">. This is shown in Figure 5. <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_221.png" alt="\epsilon_d" title="\epsilon_d" class="latex"> decreases toward 0. But as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_231.png" alt="k \rightarrow \infty" title="k \rightarrow \infty" class="latex">, it should become information-theoretically easier to decode. In fact, as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_231.png" alt="k \rightarrow \infty" title="k \rightarrow \infty" class="latex">,
 the code approaches a random linear code, which is known to achieve 
Shannon capacity. Hence we can believe that the 
information-theoretically achievable decoding rate is non-decreasing. 
Thus there is a gap between what is information theoretically possible 
to decode, and what is computationally feasible using Belief 
Propagation.</p>

<figure class="wp-block-image"><img data-attachment-id="6447" data-permalink="https://windowsontheory.org/ldpc-ed-lim-inf/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/ldpc-ed-lim-inf.png" data-orig-size="1000,664" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ldpc-ed-lim-inf" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/ldpc-ed-lim-inf.png?w=300" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/ldpc-ed-lim-inf.png?w=656" class="wp-image-6447" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/ldpc-ed-lim-inf.png" alt=""><figcaption><strong>Fig 5</strong> <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_221.png" alt="\epsilon_d" title="\epsilon_d" class="latex"> decreases as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_238.png" alt="k" title="k" class="latex"> increases, while the rate <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_110.png" alt="= 1 - l/k = 0.5" title="= 1 - l/k = 0.5" class="latex"> is fixed. In fact <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_193.png" alt="\mathrm{lim}_{k \rightarrow \infty}\epsilon_d = 0" title="\mathrm{lim}_{k \rightarrow \infty}\epsilon_d = 0" class="latex">.</figcaption></figure>

<p>Finally we would like to mention that it is possible to choose a sequence of polynomials <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_219.png" alt="(\lambda, \rho)" title="(\lambda, \rho)" class="latex"> such that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_221.png" alt="\epsilon_d" title="\epsilon_d" class="latex">
 approaches the Shannon limit. While it is non-trivial to sample exactly
 from this distribution, good approximations exist and LDPC codes can 
achieve close to channel capacity over binary erasure channels.</p>

<h3>The solution space in <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_139.png" alt="p_{d}\leq p \leq p_{c}" title="p_{d}\leq p \leq p_{c}" class="latex"></h3>

<h4>The energy landscape of LDPC decoding</h4>

<p>We have already shown the exact location of the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_165.png" alt="p_{MAP} = p_{c}" title="p_{MAP} = p_{c}" class="latex">
 threshold above which decoding is not possible for the LDPC ensemble 
and have also investigated the point at which the BP algorithm fails, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex">.</p>

<p>It should not be surprising to us that any given algorithm we attempt to throw at the problem fails at a certain point below <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex">.
 In fact there are many simple, random algorithms from the class of 
Markov-chain Monte Carlos which give fast run times but which fail at 
values far below even <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex">.
 The failing point of a particular algorithm, per se, is not necessarily
 very significant. We shouldn’t expect that any given algorithm, besides
 explicitly calculating the symbol MAP by traversing the entire 
codebook, would be able to achieve <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex">.</p>

<p>What is of interest to us here, is that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex">
 marks a provable threshold in the solution space of LDPC decoding 
during which it is likely no locally-based methods, and therefore no <em>fast </em>algorithms
 can decode with nonzero probability. We will show later precisely the 
number and energy levels of these metastable states for the BEC. Proof 
of this transition for other channel types is outside the scope of this 
lecture.</p>

<p>In this section we will rephrase decoding as an energy minimization 
problem and use three techniques to explore the existence of metastable 
states and their effect on local search algorithms.</p>

<p>In particular we will first use a generic local search algorithm that
 attempts to approximately solve energy minimization expression of 
decoding.</p>

<p>We will next use a more sophisticated Markov chain Monte Carlo method
 called simulated annealing. Simulated annealing is useful because it 
offers a perspective that more closely models real physical processes 
and that has the property that its convergence behavior closely mimics 
the structure of the metastable configurations.</p>

<h4>Energy minimization problem</h4>

<p>To begin, we will reframe our problem in terms of constraint satisfaction.</p>

<p>The codewords of an LDPC code are solutions of a CSP. The variables 
are the bits of the word and the constraints are the parity check 
equations. Though this means our constraints are a system of linear 
equations, our problem here is made more complicated by the fact that we
 are searching for not just ANY solution to the system but for a 
particular solution, namely the transmitted codeword.</p>

<p>The received message <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_124.png" alt="\underbar{\textit{y}}" title="\underbar{\textit{y}}" class="latex"> tells us where we should look for the solution.</p>

<p>Assume we are using the binary-input, memoryless, output-symmetric channel with transition probability <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_181.png" alt="\mathbf{Q}(y | x)" title="\mathbf{Q}(y | x)" class="latex">.</p>

<p>The probability that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_082.png" alt="\underbar{\textit{x}}" title="\underbar{\textit{x}}" class="latex"> was the transmitted codeword, given <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_124.png" alt="\underbar{\textit{y}}" title="\underbar{\textit{y}}" class="latex"> is <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_096.png" alt="\mathbb{P}(\underbar{\textit{x}} | \underbar{\textit{y}}) = \mu_{y}(\underbar{\textit{x}})" title="\mathbb{P}(\underbar{\textit{x}} | \underbar{\textit{y}}) = \mu_{y}(\underbar{\textit{x}})" class="latex"></p>

<p>Where</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_174.png" alt="\mu_{y}(\underline{x}|\underline{y}) = \frac{1}{Z(y)}\prod_{i=1}^NQ(y_i|x_i)\prod_{a=1}^M\mathbb{I}(x_{i_1^a}\otimes ... \otimes x_{k(a)^a} = 0)" title="\mu_{y}(\underline{x}|\underline{y}) = \frac{1}{Z(y)}\prod_{i=1}^NQ(y_i|x_i)\prod_{a=1}^M\mathbb{I}(x_{i_1^a}\otimes ... \otimes x_{k(a)^a} = 0)" class="latex"> (10)</p>

<p>We can associate an optimization problem with this code. In particular, define <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_188.png" alt="E(\underbar{\textit{x}})" title="E(\underbar{\textit{x}})" class="latex"> to be twice the number of parity check equations violated by <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_124.png" alt="\underbar{\textit{y}}" title="\underbar{\textit{y}}" class="latex">.</p>

<p>We have already discussed how symbol MAP computes the marginals of the distribution <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_158.png" alt="\mu_{y}(\underbar{\textit{x}})" title="\mu_{y}(\underbar{\textit{x}})" class="latex"> and how word MAP finds its argmax.</p>

<p>We shall here discuss two related problems</p>

<ul><li>optimizing the energy function within a subset of the configuration space defined by the received word</li><li>sampling from a ’tilted’ Boltzmann distribution associated with the energy</li></ul>

<p>Define the log-likelihood of x being the input given the received y to be</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_136.png" alt="L_{\underline{y}}(\underline{x}) = \sum_{i=1}^N Q(y_i|x_i)" title="L_{\underline{y}}(\underline{x}) = \sum_{i=1}^N Q(y_i|x_i)" class="latex"> (11)</p>

<p>If we assume WLOG that the all zero codeword was transmitted, by the law of large numbers, for large N the log-likelihood <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_196.png" alt="L_{\underbar{\textit{y}}}(\underbar{\textit{x}})" title="L_{\underbar{\textit{y}}}(\underbar{\textit{x}})" class="latex"> of this codeword is close to <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_198.png" alt="-Nh" title="-Nh" class="latex"> where <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_166.png" alt="h" title="h" class="latex"> is the channel entropy. The probability of an order-N deviation away from this value is exponentially small.</p>

<p>This suggests that we should look for the transmitted codeword amongst those <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_212.png" alt="\underbar{\textit{x}} \in \mathbb{C}" title="\underbar{\textit{x}} \in \mathbb{C}" class="latex"> such that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_196.png" alt="L_{\underbar{\textit{y}}}(\underbar{\textit{x}})" title="L_{\underbar{\textit{y}}}(\underbar{\textit{x}})" class="latex"> is close to h.</p>

<p>The constraint version of our decoding strategy – known as typical-pairs decoding – is thus, find <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_082.png" alt="\underbar{\textit{x}}" title="\underbar{\textit{x}}" class="latex"> such that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_115.png" alt="L_{\underbar{\textit{y}}}(\underbar{\textit{x}}) &gt; -N(h+\delta)" title="L_{\underbar{\textit{y}}}(\underbar{\textit{x}}) &gt; -N(h+\delta)" class="latex">.
 This constraint will be referred to as the `distance constraint’ and we
 should consider the situation where if exactly one codeword satisfies 
the distance constraint, return it.</p>

<p>Since codewords are global energy minima (<img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_076.png" alt="E(\underbar{\textit{x}}) = 0" title="E(\underbar{\textit{x}}) = 0" class="latex"> for all <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_212.png" alt="\underbar{\textit{x}} \in \mathbb{C}" title="\underbar{\textit{x}} \in \mathbb{C}" class="latex">), we can phrase typical-pairs decoding as an optimization problem</p>

<p>Minimize <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_188.png" alt="E(\underbar{\textit{x}})" title="E(\underbar{\textit{x}})" class="latex"> subject to <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_115.png" alt="L_{\underbar{\textit{y}}}(\underbar{\textit{x}}) &gt; -N(h+\delta)" title="L_{\underbar{\textit{y}}}(\underbar{\textit{x}}) &gt; -N(h+\delta)" class="latex">.</p>

<p>This decoding succeeds iff the minimum is non-degenerate. This happens with high probability for <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_186.png" alt="p &lt; p_{c}" title="p &lt; p_{c}" class="latex"> and with zero probability for <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_024.png" alt="p &gt; p_{c}" title="p &gt; p_{c}" class="latex">. In particular, there are exponentially many degenerate energy minima above <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex">.</p>

<p>Similar to what we have seen elsewhere in the course, there exists a generically intermediate regime <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_139.png" alt="p_{d}\leq p \leq p_{c}" title="p_{d}\leq p \leq p_{c}" class="latex">
 in which the global energy minimum is still the correct codeword bu 
there is an exponentially large number of local energy minima obscuring 
it (see figure 6).</p>

<p>What is so special about BP is that the threshold at which these 
exponentially many metastable states proliferate is exactly the 
algorithmic threshold <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex"> for BP which we proved earlier.</p>

<figure class="wp-block-image"><img data-attachment-id="6456" data-permalink="https://windowsontheory.org/cartoon/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/cartoon.png" data-orig-size="651,171" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="cartoon" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/cartoon.png?w=300" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/cartoon.png?w=651" class="wp-image-6456" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/cartoon.png" alt=""><figcaption><strong>Fig 6</strong> A cartoon landscape for the Energy function defined above (number of violated checks). <em>Left</em>: The energy has a unique global minimum with <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_037.png" alt="E(\underline{x}) = 0" title="E(\underline{x}) = 0" class="latex"> (the transmitted codeword) and no local minima. <em>Center</em>: many deep local minima appear, although the global minimum is non degenerate. <em>Right</em>: more than one codeword is compatible with the likelihood constraint, the global minimum <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_037.png" alt="E(\underline{x}) = 0" title="E(\underline{x}) = 0" class="latex"> is degenerate <em>adapted from Mezard and Montanari, 2009 Chapt 21</em></figcaption></figure>

<p>While finding solutions <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_076.png" alt="E(\underbar{\textit{x}}) = 0" title="E(\underbar{\textit{x}}) = 0" class="latex"> amounts to Gaussian elimination, the constraint <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_115.png" alt="L_{\underbar{\textit{y}}}(\underbar{\textit{x}}) &gt; -N(h+\delta)" title="L_{\underbar{\textit{y}}}(\underbar{\textit{x}}) &gt; -N(h+\delta)" class="latex"> is not a linear constraint. Thus one needs to use some sort of more advanced search procedure to find satisfying vectors <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_240.png" alt="\underline{x}" title="\underline{x}" class="latex">.</p>

<p>We will show that if one resorts to local-search-based algorithms, the metastable states above <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex">
 block the algorithm. Furthermore, we suggest that the behavior of the 
local algorithms discussed below are typical of all local search 
algorithms (including BP) and that it is very likely the case that no 
fast algorithm exists capable of finding global energy minima without 
getting caught in the metastable states which proliferate above <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex">.</p>

<p>Below is the simplest of local search algorithms, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_023.png" alt="\Delta" title="\Delta" class="latex">-local search.</p>

<figure class="wp-block-image is-resized"><img loading="lazy" data-attachment-id="6457" data-permalink="https://windowsontheory.org/deltasearch/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/deltasearch.png" data-orig-size="470,252" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="deltasearch" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/deltasearch.png?w=300" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/deltasearch.png?w=470" class="wp-image-6457" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/deltasearch.png" alt="" srcset="https://windowsontheory.files.wordpress.com/2018/12/deltasearch.png 470w, https://windowsontheory.files.wordpress.com/2018/12/deltasearch.png?w=150&amp;h=80 150w, https://windowsontheory.files.wordpress.com/2018/12/deltasearch.png?w=300&amp;h=161 300w" sizes="(max-width: 548px) 100vw, 548px" width="548" height="294"><figcaption><strong>Fig 7</strong><em> Excerpted from Mezard and Montanari, 2009 Chapt 21</em></figcaption></figure>

<p>Delta search typefies local search algorithms. It walks semi-randomly
 through the landscape searching for low energy configurations. Its 
parameter is defined such that, when stuck in a metastable state it can 
climb out of it in polynomial time if the steepness of its energy 
barrier is <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_104.png" alt="\leq \Delta" title="\leq \Delta" class="latex">. Thus its failure in the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_057.png" alt="p \geq p_{d}" title="p \geq p_{d}" class="latex"> region suggests that there are no barriers of constant size and that barriers of order N are the norm.</p>

<h4>MCMC and the relaxation time of a random walk</h4>

<p>We can understand the geometry of the metastable states in greater detail by reframing our MAP problem as follows:</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_204.png" alt="\mu_{y,\beta}(\underline{x}) = \frac{1}{Z(\beta)}exp{-\beta \cdot E(\underline{x})}\prod_{i=1}^N Q(y_i|x_i)" title="\mu_{y,\beta}(\underline{x}) = \frac{1}{Z(\beta)}exp{-\beta \cdot E(\underline{x})}\prod_{i=1}^N Q(y_i|x_i)" class="latex"> (12)</p>

<p>This form is referred to as the `tilted’ Boltzmann because it is a Boltzmann distribution biased by the likelihood function.</p>

<p>In the low temperature limit this reduces to eqn 10 because it finds support only over words in the codebook.</p>

<p>This distribution more closely mimics physical systems. For nonzero 
temperature it allows support over vectors which are not actually in our
 codebook but still have low distance to our received message and have 
low energy – this allows us to probe the metastable states which trap 
our local algorithms. This is referred to as a code with `soft’ parity 
check constraints as our distribution permits decodings which fail some 
checks.</p>

<p>We will use the following algorithm excerpted from Mezard and Montanari Chapt 21:</p>

<figure class="wp-block-image"><img data-attachment-id="6458" data-permalink="https://windowsontheory.org/anneal/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/anneal.png" data-orig-size="674,264" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="anneal" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/anneal.png?w=300" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/anneal.png?w=656" class="wp-image-6458" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/anneal.png" alt=""><figcaption><strong>Fig 8</strong>&nbsp;<em>Excerpted from Mezard and Montanari, 2009 Chapt 21</em></figcaption></figure>

<p>Where a Glauber update consists of scanning through the bits of the 
current proposed configuration and flipping the value of bit <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_243.png" alt="i" title="i" class="latex"> with probability</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_114.png" alt="w_{i}(\underbar{\textit{x}}) = \frac{\mu_{y,\beta}(\underline{x}^{(i)})}{\mu_{y,\beta}(\underline{x}^{(i)}) + \mu_{y,\beta}(\underline{x})}" title="w_{i}(\underbar{\textit{x}}) = \frac{\mu_{y,\beta}(\underline{x}^{(i)})}{\mu_{y,\beta}(\underline{x}^{(i)}) + \mu_{y,\beta}(\underline{x})}" class="latex"> (13)</p>

<p>Where <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_240.png" alt="\underline{x}" title="\underline{x}" class="latex"> is the current configuration and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_013.png" alt="\underline{x}^{(i)}" title="\underline{x}^{(i)}" class="latex"> is the configuration obtained by flipping <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_240.png" alt="\underline{x}" title="\underline{x}" class="latex">‘s <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_005.png" alt="i^{th}" title="i^{th}" class="latex"> bit</p>

<p>This method is a spin-off of traditional Markov chain Monte-Carlo 
algorithms with the variation that we lower the temperature according to
 an annealing schedule that initially assigns probability to all states 
proportional to the likelihood component of equation 12, allowing the 
chain to randomly sample the configuration space in the neighborhood of 
the received noisy word, until in the low temperature limit it becomes 
concentrated near to configurations which are proper codewords.</p>

<p>This method is useful to us because MCMCs are good models of how 
randomized methods of local searching for optimal configurations occurs 
in physical systems. Furthermore, the convergence of MCMCs and the time 
it takes them to converge tells us both the properties of the energy 
wells they terminate in and the barriers between minima in the energy 
landscape.</p>

<p>Let’s now show a property relating convergence times of MCMCs and energy barriers known as the Arrhenius law.</p>

<p>If we take the example of using a simple MCMC random walk with the update rule below over the following landscape</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_120.png" alt="w(x\rightarrow x') = min \{e^{-\beta [E(x')-E(x)]},~1\}" title="w(x\rightarrow x') = min \{e^{-\beta [E(x')-E(x)]},~1\}" class="latex"></p>

<figure class="wp-block-image is-resized"><img loading="lazy" data-attachment-id="6462" data-permalink="https://windowsontheory.org/fig1311/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/fig1311.png" data-orig-size="497,268" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="fig1311" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/fig1311.png?w=300" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/fig1311.png?w=497" class="wp-image-6462" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/fig1311.png" alt="" srcset="https://windowsontheory.files.wordpress.com/2018/12/fig1311.png 497w, https://windowsontheory.files.wordpress.com/2018/12/fig1311.png?w=150&amp;h=81 150w, https://windowsontheory.files.wordpress.com/2018/12/fig1311.png?w=300&amp;h=162 300w" sizes="(max-width: 540px) 100vw, 540px" width="540" height="291"><figcaption><strong>Fig 9</strong> This represents a random walk along a line in which there are two ground states separated by an energy barrier of height <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_100.png" alt="\Delta E" title="\Delta E" class="latex">.&nbsp; <em>Excerpted from Mezard and Montanari, 2009 Chapt 13</em></figcaption></figure>

<p>We find that the expected number of time steps to cross from one well to another is governed by the Arrhenius law <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_034.png" alt="\tau \approx exp{\beta \Delta E}" title="\tau \approx exp{\beta \Delta E}" class="latex">.</p>

<p>In general, if there exists a largest energy barrier between any two 
components of the configuration space (also known as the bottleneck) the
 time it takes to sample both components, also known as the relaxation 
time of the MCMC is <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_060.png" alt="\tau_{exp} \geq O(e^{\beta \Delta E})" title="\tau_{exp} \geq O(e^{\beta \Delta E})" class="latex"></p>

<p>With this in mind, we can apply our simulated annealing MCMC to LDPC 
decoding and examine the properties of the bottlenecks, or metastable 
states, in our configuration landscape.</p>

<h4>Exact values of the metastable energy states for the BEC</h4>

<p>It is a well-known consequence of the 1RSB cavity method that the number of metastable states of energy <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_116.png" alt="Ne" title="Ne" class="latex"> grows like <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_225.png" alt="exp(N\Sigma^{e}(e))" title="exp(N\Sigma^{e}(e))" class="latex"> where <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_017.png" alt="\Sigma^{e}(e)" title="\Sigma^{e}(e)" class="latex">
 is known as the energetic complexity function, a function whose form is
 implied by the 1RSB cavity equations. This computation can be carried 
out using a method called Survey Propagation which constructs a factor 
graph of the messages passed in the original BP factor graph and 
estimates the values of the marginals of the messages via another round 
of BP (hence the name 1-step RSB).</p>

<p>Neglecting the actual form of the calculations I will show the following approximate results for the BEC.</p>

<figure class="wp-block-image is-resized"><img loading="lazy" data-attachment-id="6463" data-permalink="https://windowsontheory.org/fig213/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/fig213.png" data-orig-size="799,338" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="fig213" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/fig213.png?w=300" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/fig213.png?w=656" class="wp-image-6463" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/fig213.png" alt="" srcset="https://windowsontheory.files.wordpress.com/2018/12/fig213.png?w=600&amp;h=254 600w, https://windowsontheory.files.wordpress.com/2018/12/fig213.png?w=150&amp;h=63 150w, https://windowsontheory.files.wordpress.com/2018/12/fig213.png?w=300&amp;h=127 300w, https://windowsontheory.files.wordpress.com/2018/12/fig213.png?w=768&amp;h=325 768w, https://windowsontheory.files.wordpress.com/2018/12/fig213.png 799w" sizes="(max-width: 602px) 100vw, 602px" width="602" height="254"><figcaption><strong>Fig 10</strong> Metastable states for random elements of the (3,6) regular ensemble used over the BEC (<img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_140.png" alt="\epsilon_d = .4294" title="\epsilon_d = .4294" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_043.png" alt="\epsilon_c = .4882" title="\epsilon_c = .4882" class="latex">. <em>Left</em>: the complexity function as a function of energy density above <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_221.png" alt="\epsilon_d" title="\epsilon_d" class="latex">. <em>Right</em>: the maximum and minimum energy densities of metastable states as a function of the erasure probability. Note that at <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_201.png" alt="\epsilon_d \leq .45 \leq \epsilon_c " title="\epsilon_d \leq .45 \leq \epsilon_c " class="latex">latex
 the curve is positive only for non zero metastable energy densities. 
This indicates exponentially many metastable states. At erasure rates 
above <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_232.png" alt="\epsilon_c" title="\epsilon_c" class="latex"> there are exponentially many degenerate ground states. <em>Excerpted from Mezard and Montanari, 2009 Chapt 21</em></figcaption></figure>

<p>In the regime <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_057.png" alt="p \geq p_{d}" title="p \geq p_{d}" class="latex">
 there exists a zero-energy word corresponding to the correct solution. 
On top of this, there exist non-trivial solutions to the 1RSB method 
yielding a complexity curve positive in the regime (<img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_061.png" alt="e_{c}, e_{d}" title="e_{c}, e_{d}" class="latex">).
 The positive complexity means that there are exponentially many such 
states and their finite energy means they violate a finite fraction of 
the parity checks, making their energy wells relatively deep.</p>

<p>As the error rate of the channel increases above <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex"> the minimum energy of the metastable state reaches zero continuously. This means at noise levels above <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_032.png" alt="p_{c}" title="p_{c}" class="latex">
 there are an exponential number of zero-energy states corresponding to 
configurations which aren’t code words. These codewords are separated by
 energy barriers <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_126.png" alt="O(N)" title="O(N)" class="latex"> thus making the relaxation-time of local algorithms, by the Arrhenius law <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_118.png" alt="exp(N)" title="exp(N)" class="latex"> in this regime.</p>

<figure class="wp-block-image is-resized"><img loading="lazy" data-attachment-id="6464" data-permalink="https://windowsontheory.org/fig214/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/fig214.png" data-orig-size="828,305" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="fig214" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/fig214.png?w=300" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/fig214.png?w=656" class="wp-image-6464" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/fig214.png" alt="" srcset="https://windowsontheory.files.wordpress.com/2018/12/fig214.png?w=622&amp;h=229 622w, https://windowsontheory.files.wordpress.com/2018/12/fig214.png?w=150&amp;h=55 150w, https://windowsontheory.files.wordpress.com/2018/12/fig214.png?w=300&amp;h=111 300w, https://windowsontheory.files.wordpress.com/2018/12/fig214.png?w=768&amp;h=283 768w, https://windowsontheory.files.wordpress.com/2018/12/fig214.png 828w" sizes="(max-width: 622px) 100vw, 622px" width="622" height="229"><figcaption><strong>Fig 11</strong> Decoding random codes from the (3,6) ensemble over the BEC. In both cases <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_021.png" alt="N = 10^4" title="N = 10^4" class="latex">, and the annealing schedule consists of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_152.png" alt="t_max = 1000" title="t_max = 1000" class="latex"> equidistant temperatures in <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_209.png" alt="T = 1 / \beta \in [0,1]" title="T = 1 / \beta \in [0,1]" class="latex">. <em>Left</em>: indicates convergence to the correct ground state at <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_180.png" alt="\epsilon = .4 &lt; \epsilon_d" title="\epsilon = .4 &lt; \epsilon_d" class="latex">. <em>Right</em>: indicates convergence to approximately the energy density of the highest metastable states <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_125.png" alt="e_d" title="e_d" class="latex"> (as calculated by the complexity function via 1RSB) for <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_040.png" alt="\epsilon = .6 &gt; \epsilon_{c}" title="\epsilon = .6 &gt; \epsilon_{c}" class="latex">.&nbsp;<em>Excerpted from Mezard and Montanari, 2009 Chapt 21</em><br><br></figcaption></figure>

<p>Here you can see a rough sketch of convergence of the simulated annealing algorithm. As the temperature decreases in the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_171.png" alt="p \leq p_{d}" title="p \leq p_{d}" class="latex">
 regime the algorithm converges to a 0 energy ground state. In the 
figure on the right we can see that simulated annealing converges to the
 horizontal line here which corresponds to the energy of the highest 
metastable state <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_226.png" alt="e_{d}" title="e_{d}" class="latex"> for the BEC at <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_234.png" alt="p = .6" title="p = .6" class="latex">.</p>

<p>Thus we see our local search algorithms end up being attracted to the highest energy of the metastable state.</p>

<figure class="wp-block-image"><img data-attachment-id="6465" data-permalink="https://windowsontheory.org/fig215/" data-orig-file="https://windowsontheory.files.wordpress.com/2018/12/fig215.png" data-orig-size="555,323" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="fig215" data-image-description="" data-medium-file="https://windowsontheory.files.wordpress.com/2018/12/fig215.png?w=300" data-large-file="https://windowsontheory.files.wordpress.com/2018/12/fig215.png?w=555" class="wp-image-6465" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/fig215.png" alt=""><figcaption><strong>Fig 12</strong>
 Decoding random codes as in figure 11. Here we plot the minimum energy 
density achieved through simulated annealing plotted as a function of 
the erasure probability of the BEC. The continuous line indicates the 
highest lying metastable states as calculated from the complexity 
function via 1RSB.<br><em>&nbsp;Excerpted from Mezard and Montanari, 2009 Chapt 21</em></figcaption></figure>

<p>Though there is not necessarily an exact correspondence between the 
residual energy at T=0 for simulated annealing and the highest 
metastable state <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_226.png" alt="e_{d}" title="e_{d}" class="latex"> we see that across all values of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_239.png" alt="p" title="p" class="latex"> that at T=0, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_128.png" alt="e_{ann} \approx e_{d}" title="e_{ann} \approx e_{d}" class="latex"> suggesting local search tends to get caught in the deepest metastable energy wells.</p>

<p>This discussion shows that the algorithmic threshold of BP, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_079.png" alt="p_{d}" title="p_{d}" class="latex"> indicates the onset of a truly different regime within the energy landscape of the codebook. Metastable states of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_126.png" alt="O(N)" title="O(N)" class="latex">
 hight proliferate and become exponentially difficult to escape from via
 local search methods. Thus the failure of BP likely indicates a regime 
in which no fast algorithms can perform decoding, even though decoding 
is still theoretically possible when below <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex.png" alt="p_c" title="p_c" class="latex">, e.g. via exhaustive search of the codebook.</p>

<h3>Appendix A:&nbsp;Random Code Ensembles</h3>

<p>In an RCE, encoding maps applied to the information sequence are 
chosen with uniform probability over a solution space. Two decoding 
schemes are often used and applied to the noise – word MAP and symbol 
MAP decoding. MAP, otherwise known as “maximum <em>a priori</em> 
probability” works by maximizing the probability distribution to output 
the most probable transmission. Word MAP decoding schemes output the 
codeword with the highest probability by minimizing the block error 
probability, which is otherwise known as the probability with respect to
 the channel distribution that the decoded word is different than the 
true transmitted word. Symbol MAP decoding, on the other hand, minimizes
 the fraction of incorrect bits averaged over the transmitted code word 
(bit error rate).</p>

<p>RCE code is defined by the codebook in Hamming space, or the set of all binary strings of length <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_211.png" alt="N" title="N" class="latex">.
 In a Hamming space characterized by uniform probability, the number of 
codewords at a given Hamming distance are a function of the distance 
enumerator. Distance enumerators take as parameters different weights, 
given that probabilities of codewords are independent of each other. The
 distance enumerator shows that, for small enough fractional distance 
from the true message <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_197.png" alt="x_0" title="x_0" class="latex">, the growth rate is negative and the average number of codewords at small distance from <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_197.png" alt="x_0" title="x_0" class="latex">
 vanishes exponentially with N. The Gilbert-Varshamov distance, a lower 
bound threshold, shows that the the average number of codewords is 
exponentially large at points where the weight numerator is 
concentrated.</p>

<p>We look at the performance of RCE code in communication over the 
Binary Symmetric Channel (BSC), where it is assumed that there is a 
probability p that transmitted bits will be “flipped” (i.e. with 
probability p, 1 becomes 0 and 0 becomes 1). With BSCs, channel input 
and output are the same length N sequences of bits. At larger noise 
levels, there are an exponential number of codewords closer to <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_065.png" alt="y" title="y" class="latex"> and decoding is unsuccessful. However, decoding via the symbol MAP decoding scheme shows that the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_243.png" alt="i" title="i" class="latex">-th
 bit is decoded by maximizing the marginal probability and amasses 
contributions from all codewords in the set. Above a threshold, the bit 
error rate is the same as if the message was transmitted without 
encoding and decoding, but below this, the RCE seems to work quite well 
in transmission.</p>

<p>Finite temperature decoding has also been looked at as an 
interpolation between the two MAP decoding schemes. At low noise, a 
completely ordered phase can be observed as compared to a glassy phase 
at higher noise channels. Similar to the a statistical physics model, we
 can also note an entropy dominated paramagnetic phase at higher 
temperatures.</p>

<p>Each decoding scheme can be analogized to “sphere packing”, where 
each probability in the Hamming space distribution represents a sphere 
of radius r. Decoding schemes have partitions in the Hamming space, so 
these spheres must be disjoint. If not, intersecting spheres must be 
eliminated. The lower bound of the remaining spheres is then given by 
Gilbert-Varshamov bound, whereas the upper bound is dictated by the 
Hamming distance.</p>

<p>Another random code beside the RCE is the RLC, or random linear code.
 Encoding in an RLC forms a scheme similar to a linear map, of which all
 points are equiprobable. The code is specified by an <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_033.png" alt="N x M" title="N x M" class="latex"> binary matrix, otherwise known as the generating matrix, and it is projected to be error-free below the Shannon capacity.</p>

<p>There are several sources of randomness in codes. Codes are chosen 
randomly from an ensemble and the codeword to be transmitted is chosen 
with uniform probability from the code, according to the theorem of 
source-channel separation. The channel output is then distributed 
according to a probabilistic process accounting for channel noise and 
decoding is done by constructing another probability distribution over 
possible channel inputs and by estimating its signal bit marginal. The 
decision on the <em>i</em>-th bit is dependent on the distribution. 
Thus, complications may arise in distinguishing between the two levels 
of randomness: code, channel input, and noise (“quenched” disorder) 
versus Boltzmann probability distributions.</p>

<h3>Appendix B:&nbsp;Weight enumerators and code performance</h3>

<p>The geometric properties of the LDPC codebooks is given by studying the distance enumerator <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_216.png" alt="N_{\underline{x}0}(d)" title="N_{\underline{x}0}(d)" class="latex"> to give the number of codewords at Hamming distance <em>d</em> from <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_215.png" alt="\underline{x}_0" title="\underline{x}_0" class="latex">. This takes all-zeros codewords as the reference and uses the weight enumerator, <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_157.png" alt="\mathbb{N}(w)=\mathbb{N}{\underline{x_0}}(d=w)" title="\mathbb{N}(w)=\mathbb{N}{\underline{x_0}}(d=w)" class="latex"> as the denomination (number of codewords having weight equal to <em>w</em>). To estimate the expected weight enumerator <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_163.png" alt="\mathcal{N}(w)=\mathbb{E}\mathbb{N}(w)" title="\mathcal{N}(w)=\mathbb{E}\mathbb{N}(w)" class="latex"> for a random code in the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_053.png" alt="LDPC_N(\Lambda,P)" title="LDPC_N(\Lambda,P)" class="latex"> ensemble, we know that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_245.png" alt="\mathbb{N}(w)" title="\mathbb{N}(w)" class="latex"> grows exponentially in block-length <em>N</em>, and that each codeword has a weight <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_018.png" alt="w=Nw" title="w=Nw" class="latex"> that grows linearly with N. The exponential growth rate <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_195.png" alt="\phi(w)" title="\phi(w)" class="latex"> is defined by</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_129.png" alt="\mathcal{N}(w=Nw) = e^{N \phi (w)}" title="\mathcal{N}(w=Nw) = e^{N \phi (w)}" class="latex"> (14)</p>

<p>denoting an ‘annealed average’, or a disordered system that could be 
dominated by rare instances in the ensemble. This gives an upper bound 
on the number of ‘colored factor graphs’ that have an even number of 
weighted incident edges divided by the total number of factor graphs in 
the ensemble.</p>

<p>On the other hand, for graphs of fixed degrees with N variable nodes of degree<em> l</em> and M function nodes of degree <em>k</em>, the total number of edges F is given by <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_086.png" alt="F=Mk=Nl" title="F=Mk=Nl" class="latex">. A valid colored graph would have <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_002.png" alt="E=wl" title="E=wl" class="latex"> edges, with the number of variable nodes given in <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_101.png" alt="{N\choose w}" title="{N\choose w}" class="latex"> ways, l assignments of weighted sockets to nodes, and l assignments of unweighted sockets to nodes outside the set. If we take <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_149.png" alt="m_r" title="m_r" class="latex"> to denote the number of function nodes with weighted sockets under the constraints of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_008.png" alt="\Sigma_{r=0}^km_r=M" title="\Sigma_{r=0}^km_r=M" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_109.png" alt="\Sigma_{r=0}^krm_r=lw" title="\Sigma_{r=0}^krm_r=lw" class="latex">, we find the number of ways to color the function node sockets by</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_185.png" alt="\mathbb{C}(k,M,w) = \sum_{m_{0},...m_{k}}^{even}{M\choose m_{0},...,m_{k}}\prod_{r}{k\choose r}^{m_{r}}" title="\mathbb{C}(k,M,w) = \sum_{m_{0},...m_{k}}^{even}{M\choose m_{0},...,m_{k}}\prod_{r}{k\choose r}^{m_{r}}" class="latex"> (15)</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_105.png" alt="\mathbb{I}\Big(\sum_{r=0}^km_r=M\Big)\mathbb{I}\Big(\sum_{r=0}^krm_r=lw\Big)" title="\mathbb{I}\Big(\sum_{r=0}^km_r=M\Big)\mathbb{I}\Big(\sum_{r=0}^krm_r=lw\Big)" class="latex"> (16)</p>

<p>If we aim to join variable and check nodes so that colorings are matched, knowing that there are <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_224.png" alt="(lw)!(F-lw)!" title="(lw)!(F-lw)!" class="latex"> possible matchings in each ensemble element, this yields the following formula:</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_208.png" alt="\mathcal{N}(w)=\frac{(lw)!(F-lw)!}{F!}{N\choose w}\mathbb{C}(k,M,w)" title="\mathcal{N}(w)=\frac{(lw)!(F-lw)!}{F!}{N\choose w}\mathbb{C}(k,M,w)" class="latex"> (17)</p>

<p>At low noise limits, code performance depends on the existence of 
codewords at distances close to the transmitted codeword. Starting with 
degree 1 and knowing that the parametric representation for weights is 
given by&nbsp;</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_160.png" alt="w = \sum_{l=1}^{l_{max}}\Lambda_l\frac{xy^l}{1+xy^l}" title="w = \sum_{l=1}^{l_{max}}\Lambda_l\frac{xy^l}{1+xy^l}" class="latex"> (18)</p>

<p>derive that&nbsp;</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_052.png" alt="\phi(w) = -\frac{1}{2}w\log(w/\Lambda_1^2)+O(w)" title="\phi(w) = -\frac{1}{2}w\log(w/\Lambda_1^2)+O(w)" class="latex"> (19)</p>

<p>when <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_177.png" alt="x,y,z" title="x,y,z" class="latex"> scale to <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_015.png" alt="\sqrt{w}" title="\sqrt{w}" class="latex">. This shows that the exponential growth rate <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_195.png" alt="\phi(w)" title="\phi(w)" class="latex"> is strictly positive when <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_059.png" alt="w" title="w" class="latex">
 is sufficiently small, and that the expected number of codewords within
 a small Hamming distance from a given codeword is exponential in N. If 
we take the logarithm of the expected weight enumerator and plot this 
versus the reduced weight <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_070.png" alt="w=w/N" title="w=w/N" class="latex"> for an irregular code with <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_236.png" alt="l_{min}=1" title="l_{min}=1" class="latex">, we see that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_195.png" alt="\phi(w)" title="\phi(w)" class="latex"> is positive near the origin, but that its dervative diverges as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_145.png" alt="w\rightarrow 0" title="w\rightarrow 0" class="latex">.
 Since this means that each codeword is surrounded by a large number of 
very close other codewords, this makes the code a very bad ECC and thus,
 makes it hard to discriminate between codewords at Hamming distances <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_022.png" alt="O(1)" title="O(1)" class="latex"> with noisy observations. Applying this same logic to <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_146.png" alt="l" title="l" class="latex"> of min 2, we still observe that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_195.png" alt="\phi(w)" title="\phi(w)" class="latex"> tends to 0 more quickly as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_145.png" alt="w\rightarrow 0" title="w\rightarrow 0" class="latex"> in the present case. If we assume that this holds beyond the asymptotic regime, we get</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_230.png" alt="\bar{\mathcal{N}}(w) = e^{Aw}" title="\bar{\mathcal{N}}(w) = e^{Aw}" class="latex"> (20)</p>

<p>or that the number of codewords around a particular codeword is <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_169.png" alt="o(N)" title="o(N)" class="latex"> until a Hamming distance <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_194.png" alt="d_* \simeq \log N/A" title="d_* \simeq \log N/A" class="latex">, otherwise known as the “effective minimum distance”. For <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_220.png" alt="l_{min} \geq 3" title="l_{min} \geq 3" class="latex">, we find:</p>

<p><br><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_237.png" alt="\phi(w) \simeq \Big(\frac{l_{min}-2}{2}\Big)w\log\Big(\frac{w}{\Lambda_{l_min}}\Big)" title="\phi(w) \simeq \Big(\frac{l_{min}-2}{2}\Big)w\log\Big(\frac{w}{\Lambda_{l_min}}\Big)" class="latex"> (21)</p>

<p>suggesting that LDPC codes with this property have good short 
distance behavior. Thus, any error that changes a fraction of the bits 
smaller than <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_067.png" alt="w_{*}/2" title="w_{*}/2" class="latex"> can be corrected in the absence of codewords within an extensive distance <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_138.png" alt="Nw_{*}" title="Nw_{*}" class="latex">.</p>

<p>Let us now focus on the capacity of LDPC codes to correct typical 
errors in a probabilistic channel. For binary symmetric channels that 
flip each transmitted bit independently with probability <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_175.png" alt="p&lt;\frac{1}{2}" title="p&lt;\frac{1}{2}" class="latex">. If the all-zero codeword <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_029.png" alt="\underline{x}^{(0)} =\underline{0}" title="\underline{x}^{(0)} =\underline{0}" class="latex"> has been transmitted as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_003.png" alt="\underline{y}" title="\underline{y}" class="latex">, whose components are iid random variables that take value 0 with probability <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_113.png" alt="1-p" title="1-p" class="latex"> and value 1 with probability <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_239.png" alt="p" title="p" class="latex">, then we use the MAP decoding strategy to minimize the block error rate and output the codeword closest to the channel output <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_003.png" alt="\underline{y}" title="\underline{y}" class="latex">. The expectation value of the code ensemble <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_117.png" alt="P_B = \mathbb{E}P_B(\mathbb{C})" title="P_B = \mathbb{E}P_B(\mathbb{C})" class="latex"> is an indicator of code ensemble performances. We will show that, as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_019.png" alt="N\rightarrow \infty" title="N\rightarrow \infty" class="latex">, codes with <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_155.png" alt="l_{min}\geq 3" title="l_{min}\geq 3" class="latex">
 will undergo a phase transition separating a low noise from a high 
noise phase. To derive a lower bound for the capacity of LDPC codes in a
 BSC channel, we take <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_210.png" alt="\mathbb{N}=2^{NR}" title="\mathbb{N}=2^{NR}" class="latex"> as the size of the codebook <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_148.png" alt="\mathbb{C}" title="\mathbb{C}" class="latex"> and, by union bound:</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_098.png" alt="P_{B}(\mathbb{C})= \mathbb{P}\Big\{\exists \alpha \neq 0 \text{s.t. } d(\underline{x}^{(\alpha)},\underline{y})\leq d(\underline{0},\underline{y})\Big\}" title="P_{B}(\mathbb{C})= \mathbb{P}\Big\{\exists \alpha \neq 0 \text{s.t. } d(\underline{x}^{(\alpha)},\underline{y})\leq d(\underline{0},\underline{y})\Big\}" class="latex"> (22)</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_222.png" alt="\leq \sum_{\alpha=1}^{\textit{N}-1}\mathbb{P}\Big\{d(\underline{x}^{(\alpha)},\underline{y}) \leq d(\underline{0},\underline{y})\Big\}" title="\leq \sum_{\alpha=1}^{\textit{N}-1}\mathbb{P}\Big\{d(\underline{x}^{(\alpha)},\underline{y}) \leq d(\underline{0},\underline{y})\Big\}" class="latex"> (23)</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_030.png" alt="\leq \sum_{w=1}^N \textit{N}(w)e^{-\gamma w}" title="\leq \sum_{w=1}^N \textit{N}(w)e^{-\gamma w}" class="latex"> (24)</p>

<p>This derivation proves that the block error probability depends on the weight enumerator and the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_122.png" alt="exp(-\gamma w)" title="exp(-\gamma w)" class="latex">.
 This second term shows that an increase in the weight of the codeword 
corresponds to their contribution being scaled down by an exponential 
factor. This is because it is less likely that the received message <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_003.png" alt="\underline{y}" title="\underline{y}" class="latex">
 will be closer to a codeword of large weight than to the all-zero 
codeword. A geometric construction of this phenomena implies that for 
large enough <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_239.png" alt="p" title="p" class="latex">, Shannon’s Theorem implies that <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_006.png" alt="P_B" title="P_B" class="latex"> is bounded away from 0 for any non-vanishing rate <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_056.png" alt="R &gt; 0" title="R &gt; 0" class="latex"> so that at any p less than the ML threshold for which the <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_035.png" alt="lim_{N\rightarrow \infty}P_B=0" title="lim_{N\rightarrow \infty}P_B=0" class="latex">,
 one can communicate with an arbitrarily small error probability. At a 
probability equal to the lower bound, the upper bound on <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_006.png" alt="P_B" title="P_B" class="latex"> is dominated by codewords of weight <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_132.png" alt="w \approx N\Tilde{w}" title="w \approx N\Tilde{w}" class="latex">,
 suggesting that each time an error occurs, a finite fraction of the its
 are decoded incorrectly and that this fraction doesn’t change very much
 per transmission. The construction also illustrates that this fraction 
of incorrectly decoded bits jumps discontinuously from 0 to a finite 
value when <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_239.png" alt="p" title="p" class="latex"> crosses the critical value <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_009.png" alt="p_{ML}" title="p_{ML}" class="latex">, constituting a “gap.” This gap is close to a factor of 2.</p>

<h3>Appendix C:&nbsp;BP performance</h3>

<p>See figure 2 for an illustration of a factor graph illustrating this 
relationship. Again, recall that for LDPC code ensembles in large 
block-length limits, the degree distributions of variable nodes and 
check nodes are given by <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_161.png" alt="\Lambda = {\Lambda_t}" title="\Lambda = {\Lambda_t}" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_055.png" alt="P = {P_k}" title="P = {P_k}" class="latex"> respectively, where we assume that messages are initialized to <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_203.png" alt="u_{a\rightarrow i}^{(0)} = 0" title="u_{a\rightarrow i}^{(0)} = 0" class="latex">
 for simplicity. This implies that the bit error probability is 
independent of the transmitted codeword and that therefore, we have the 
freedom to assume transmission of the all-zero codeword. In analyzing 
the recursion at the basis of the BP algorithm, we can show that 
decoding performance improves over time on the basis of symmetry and 
physical degradation.</p>

<h4>Symmetry</h4>

<p>Symmetry of channel log-likelihood and the variables appearing in 
density evolution are attributes of a desired BMS channel, suggesting 
that symmetry is preserved by BP operations in evolution. If we assume 
that the factor graph associated with an LDPC code is “tree-like”, we 
can apply BP decoding with a symmetric random initial condition and note
 that the messages <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_228.png" alt="u_{a\rightarrow i}^{(t)}" title="u_{a\rightarrow i}^{(t)}" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_207.png" alt="h_{i\rightarrow a}^{(t)}" title="h_{i\rightarrow a}^{(t)}" class="latex"> are symmetric variables at all <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_133.png" alt="t\geq 0" title="t\geq 0" class="latex">.
 This observance of symmetry is analogous to the Nishimori condition in 
spin glasses and holds for the MAP log-likelihood of a bit as well.</p>

<h4>Physical degradation</h4>

<p>Let’s first define physical degradation with BMS channels. If we take
 two channels BMS(1) and BMS(2) denoted by transition matrices</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_246.png" alt="\{Q_{1}(y|x)\}, \{Q_{2}(y|x)\}" title="\{Q_{1}(y|x)\}, \{Q_{2}(y|x)\}" class="latex"> and output alphabets <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_099.png" alt="\mathbb{Y}_1,\mathbb{Y}_2" title="\mathbb{Y}_1,\mathbb{Y}_2" class="latex">, then BMS(2) is physically degraded with respect to BMS(1) if there exists a third channel C with input alphabet <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_099.png" alt="\mathbb{Y}_1,\mathbb{Y}_2" title="\mathbb{Y}_1,\mathbb{Y}_2" class="latex"> such that BMS(2) is the concatenation of BMS(1) and C. If we represent transition matrix C as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_071.png" alt="\{R(y_2|y_1)\}" title="\{R(y_2|y_1)\}" class="latex"> we can represent the above physical degradation as</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_077.png" alt="Q_2(y_2|x) = \sum{y_1 \in \textit{Y}_1}R(y_2|y_1)Q_1(y_1|x)" title="Q_2(y_2|x) = \sum{y_1 \in \textit{Y}_1}R(y_2|y_1)Q_1(y_1|x)" class="latex"> (25)</p>

<p>&nbsp;This is analogous to a Markov chain <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_058.png" alt="X \rightarrow Y_1 \rightarrow Y_2" title="X \rightarrow Y_1 \rightarrow Y_2" class="latex">
 following partial ordering. Channel reliability is then ordered by 
measures of conditional entropy and bit error rate. This extends to 
symmetric random variables, which are associated with BMS channels.</p>

<h4>Thresholds</h4>

<p>We then fix a particular LDPC code and look at BP messages as random variables due to randomness in the vector <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_003.png" alt="\underline{y}" title="\underline{y}" class="latex"> with regards to the proposition down below, showing that the bit error rate decreases monotonously with time:</p>

<p><strong>Proposition:</strong><em>&nbsp;If <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_127.png" alt="B_{i,r}(F)" title="B_{i,r}(F)" class="latex"> is a tree, then <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_090.png" alt="h_i^{(0)}\preceq h_i^{(1)} \preceq ... \preceq h_i^{(t-1)} \preceq h_i^{(t)}" title="h_i^{(0)}\preceq h_i^{(1)} \preceq ... \preceq h_i^{(t-1)} \preceq h_i^{(t)}" class="latex"> for any <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_162.png" alt="t\leq r-1" title="t\leq r-1" class="latex">. Analogously, if <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_151.png" alt="B_{i\rightarrow a,r}(F)" title="B_{i\rightarrow a,r}(F)" class="latex">, then <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_154.png" alt="h_{i\rightarrow a}^{(0)}\preceq h_{i\rightarrow a}^{(1)} \preceq ... \preceq h_{i\rightarrow a}^{(t-1)} \preceq h_{i\rightarrow a}^{(t)}" title="h_{i\rightarrow a}^{(0)}\preceq h_{i\rightarrow a}^{(1)} \preceq ... \preceq h_{i\rightarrow a}^{(t-1)} \preceq h_{i\rightarrow a}^{(t)}" class="latex"> for any <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_162.png" alt="t\leq r-1" title="t\leq r-1" class="latex">.</em></p>

<p>Density evolution in this manner is a useful estimate of the number of distributions of density evolution variables <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_048.png" alt="{h^{(t)},u^{(t)}}" title="{h^{(t)},u^{(t)}}" class="latex"> and <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_085.png" alt="{h_{*}^{(t)}}" title="{h_{*}^{(t)}}" class="latex">. By looking again at the bit error rate <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_028.png" alt="P_{b}^{(t)}" title="P_{b}^{(t)}" class="latex"> and the conditional entropy <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_036.png" alt="H^{(t)}" title="H^{(t)}" class="latex"> as both monotonically decreasing functions of the number of iterations and conversely, monotonically increasing functions of <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_239.png" alt="p" title="p" class="latex">, we can derive a finite limit <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_199.png" alt="P_b^{BP} \equiv \lim_{t\rightarrow\infty}P_b^{(t)}" title="P_b^{BP} \equiv \lim_{t\rightarrow\infty}P_b^{(t)}" class="latex">. The corresponding BP threshold can then be defined as</p>

<p><img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_247.png" alt="p_{d} \equiv \sup \Big\{ p \in [0,1/2] : P_b^{BP}(p)=0 \Big\}" title="p_{d} \equiv \sup \Big\{ p \in [0,1/2] : P_b^{BP}(p)=0 \Big\}" class="latex"></p>

<p>For <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_078.png" alt="p \leq p_d" title="p \leq p_d" class="latex">, however, increasing the number of iterations does not help as the bit error rate is asymptotically lower bounded by <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_142.png" alt="P_{b}^{BP}(p)&gt;0" title="P_{b}^{BP}(p)&gt;0" class="latex"> for a fixed number of iterations. Good LDPC codes are thus designed with a large BP threshold with design rate <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_123.png" alt="R_{des}=1-P'(1)/\Lambda '(1)" title="R_{des}=1-P'(1)/\Lambda '(1)" class="latex">
 to maximize the threshold noise level for a given degree distribution 
pair. This ensemble will have a finite fraction of variable nodes of 
degree 2 and a large number of codewords with small weight, which 
ultimately prevent the block error probability from vanishing as <img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/latex_019.png" alt="N\rightarrow \infty" title="N\rightarrow \infty" class="latex">.</p>

<h4>References</h4>

<p>[1]&nbsp;Marc Mezard and Andrea Montanari. <br><em>Information, Physics, and Computation</em>. <br>Oxford Graduate Texts, 2009.</p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><div class="sharedaddy sd-sharing-enabled"><div class="robots-nocontent sd-block sd-social sd-social-icon-text sd-sharing"><h3 class="sd-title">Share this:</h3><div class="sd-content"><ul data-sharing-events-added="true"><li class="share-twitter"><a rel="nofollow noopener noreferrer" data-shared="sharing-twitter-6363" class="share-twitter sd-button share-icon" href="https://windowsontheory.org/2018/12/16/algorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code/?share=twitter&amp;nb=1" target="_blank" title="Click to share on Twitter"><span>Twitter</span></a></li><li class="share-end"></li></ul></div></div></div><div class="sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-loaded" id="like-post-wrapper-32349634-6363-5ff8e3dd74ba0" data-src="//widgets.wp.com/likes/index.html?ver=20200826#blog_id=32349634&amp;post_id=6363&amp;origin=windowsontheory.wordpress.com&amp;obj_id=32349634-6363-5ff8e3dd74ba0&amp;domain=windowsontheory.org" data-name="like-post-frame-32349634-6363-5ff8e3dd74ba0"><h3 class="sd-title">Like this:</h3><div class="likes-widget-placeholder post-likes-widget-placeholder" style="height: 55px; display: none;"><span class="button"><span>Like</span></span> <span class="loading">Loading...</span></div><iframe class="post-likes-widget jetpack-likes-widget" name="like-post-frame-32349634-6363-5ff8e3dd74ba0" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/index.html" width="100%" height="55px" frameborder="0"></iframe><span class="sd-text-color"></span><a class="sd-link-color"></a></div>
<div id="jp-relatedposts" class="jp-relatedposts" style="display: block;">
	<h3 class="jp-relatedposts-headline"><em>Related</em></h3>
<div class="jp-relatedposts-items jp-relatedposts-items-minimal"><p class="jp-relatedposts-post jp-relatedposts-post0" data-post-id="7489" data-post-format="false"><span class="jp-relatedposts-post-title"><a class="jp-relatedposts-post-a" href="https://windowsontheory.org/2019/03/30/physics-computation-blog-post-round-up/" title="Physics &amp; Computation Blog Post Round-up" data-origin="6363" data-position="0">Physics &amp; Computation Blog Post Round-up</a></span><span class="jp-relatedposts-post-context">With 1 comment</span></p><p class="jp-relatedposts-post jp-relatedposts-post1" data-post-id="1366" data-post-format="false"><span class="jp-relatedposts-post-title"><a class="jp-relatedposts-post-a" href="https://windowsontheory.org/2012/07/31/truth-vs-proof-the-unique-games-conjecture-and-feiges-hypothesis/" title="Truth vs Proof: The Unique Games Conjecture and Feige's Hypothesis" data-origin="6363" data-position="1">Truth vs Proof: The Unique Games Conjecture and Feige's Hypothesis</a></span><span class="jp-relatedposts-post-context">With 29 comments</span></p><p class="jp-relatedposts-post jp-relatedposts-post2" data-post-id="2629" data-post-format="false"><span class="jp-relatedposts-post-title"><a class="jp-relatedposts-post-a" href="https://windowsontheory.org/2013/10/07/structure-vs-combinatorics-in-computational-complexity/" title="Structure vs. Combinatorics in Computational Complexity" data-origin="6363" data-position="2">Structure vs. Combinatorics in Computational Complexity</a></span><span class="jp-relatedposts-post-context">In "physics"</span></p></div></div></div>			</div><!-- .entry-content -->

	<footer class="entry-footer">
				<span class="cat-links">
			Posted in <a href="https://windowsontheory.org/category/physics/" rel="category tag">physics</a>		</span>
							<span class="tags-links">
				<a href="https://windowsontheory.org/tag/belief-propagation/" rel="tag">Belief propagation</a><a href="https://windowsontheory.org/tag/coding-theory/" rel="tag">coding theory</a><a href="https://windowsontheory.org/tag/cs229r/" rel="tag">cs229r</a><a href="https://windowsontheory.org/tag/ldpc/" rel="tag">LDPC</a><a href="https://windowsontheory.org/tag/statistical-physics/" rel="tag">statistical physics</a><a href="https://windowsontheory.org/tag/thresholding-behavior/" rel="tag">thresholding behavior</a>			</span>
			</footer><!-- .entry-footer -->

		<div class="entry-author author-avatar-show">
				<div class="author-avatar">
			<img alt="" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/8c5c9e238d6dc6aba53adb08facb1313.png" class="avatar avatar-60 grav-hashed grav-hijack" id="grav-8c5c9e238d6dc6aba53adb08facb1313-0" width="60" height="60">		</div><!-- .author-avatar -->
		
		<div class="author-heading">
			<h2 class="author-title">Published by <span class="author-name">Jeremy Dohmann</span></h2>
		</div><!-- .author-heading -->

		<p class="author-bio">
						<a class="author-link" href="https://windowsontheory.org/author/dohmanna47993cfd3/" rel="author">
				View all posts by Jeremy Dohmann			</a>
		</p><!-- .author-bio -->
	</div><!-- .entry-auhtor -->
</article><!-- #post-## -->

			
	<nav class="navigation post-navigation" role="navigation" aria-label="Posts">
		<h2 class="screen-reader-text">Post navigation</h2>
		<div class="nav-links"><div class="nav-previous"><a href="https://windowsontheory.org/2018/12/13/ising-perceptron-under-gaussian-disorder-and-k-nae-sat/" rel="prev"><span class="meta-nav">‹ Previous</span>Ising Perceptron under Gaussian Disorder, and&nbsp;k-NAE-SAT</a></div><div class="nav-next"><a href="https://windowsontheory.org/2018/12/18/a-1d-area-law-for-gapped-local-hamiltonians/" rel="next"><span class="meta-nav">Next ›</span>A 1D Area Law for Gapped Local&nbsp;Hamiltonians</a></div></div>
	</nav>
			
		
		</main><!-- #main -->
	</div><!-- #primary -->

	<div id="secondary" class="widget-area" role="complementary">
		<aside id="blog_subscription-4" class="widget widget_blog_subscription jetpack_subscription_widget"><h1 class="widget-title"><label for="subscribe-field">Follow Blog via Email</label></h1>
			<form action="https://subscribe.wordpress.com" method="post" accept-charset="utf-8" id="">
									<p>Enter your email address to follow this blog and receive notifications of new posts by email.</p>
						<div class="jetpack-subscribe-count">
							<p>
							Join 724 other followers							</p>
						</div>
											<p id="subscribe-email">
						<label id="subscribe-field-label" for="subscribe-field" class="screen-reader-text">
							Email Address:						</label>

						<input type="text" name="email" style="width: 95%; padding: 1px 10px" placeholder="Enter your email address" id="subscribe-field">					</p>
				
				<p id="subscribe-submit">
                    <input type="hidden" name="action" value="subscribe">
                    <input type="hidden" name="blog_id" value="32349634">
                    <input type="hidden" name="source" value="https://windowsontheory.org/2018/12/16/algorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code/">
                    <input type="hidden" name="sub-type" value="widget">
                    <input type="hidden" name="redirect_fragment" value="blog_subscription-4">
					<input type="hidden" id="_wpnonce" name="_wpnonce" value="116d41c26a">                    <button type="submit">
	                    Follow                    </button>
                </p>
            </form>
			
</aside><aside id="twitter_timeline-3" class="widget widget_twitter_timeline"><h1 class="widget-title">Follow me on Twitter</h1><iframe id="twitter-widget-0" scrolling="no" allowtransparency="true" allowfullscreen="true" class="twitter-timeline twitter-timeline-rendered" style="position: static; visibility: visible; display: inline-block; width: 300px; height: 350px; padding: 0px; border: medium none; max-width: 100%; min-width: 180px; margin-top: 0px; margin-bottom: 0px; min-height: 200px;" data-widget-id="profile:boazbaraktcs" title="Twitter Timeline" frameborder="0"></iframe></aside><aside id="search-2" class="widget widget_search"><h1 class="widget-title">Search This Blog</h1><form role="search" method="get" class="search-form" action="https://windowsontheory.org/">
				<label>
					<span class="screen-reader-text">Search for:</span>
					<input type="search" class="search-field" placeholder="Search …" name="s">
				</label>
				<input type="submit" class="search-submit" value="Search">
			</form></aside><aside id="top-posts-4" class="widget widget_top-posts"><h1 class="widget-title">Top Posts</h1><ul>				<li>
					<a href="https://windowsontheory.org/2019/12/05/deep-double-descent/" class="bump-view" data-bump-view="tp">Deep Double Descent (cross-posted on OpenAI blog)</a>					</li>
								<li>
					<a href="https://windowsontheory.org/2014/04/15/restricted-invertiblity-by-interlacing-polynomials/" class="bump-view" data-bump-view="tp">Restricted Invertiblity by Interlacing Polynomials</a>					</li>
								<li>
					<a href="https://windowsontheory.org/2020/10/18/understanding-generalization-requires-rethinking-deep-learning/" class="bump-view" data-bump-view="tp">Understanding generalization requires rethinking deep learning?</a>					</li>
								<li>
					<a href="https://windowsontheory.org/2012/05/02/building-the-swiss-army-knife/" class="bump-view" data-bump-view="tp">Building the Swiss Army Knife</a>					</li>
								<li>
					<a href="https://windowsontheory.org/2018/01/03/intro-tcs-course-post-mortem/" class="bump-view" data-bump-view="tp">Intro TCS course post-mortem</a>					</li>
								<li>
					<a href="https://windowsontheory.org/2020/11/19/updated-research-masters-programs-database-by-aviad-rubinstein-and-matt-weinberg/" class="bump-view" data-bump-view="tp">Updated Research Masters programs database by Aviad Rubinstein and Matt Weinberg</a>					</li>
								<li>
					<a href="https://windowsontheory.org/2020/12/03/obfuscation-the-season-4-finale/" class="bump-view" data-bump-view="tp">Obfuscation: The season 4 Finale</a>					</li>
								<li>
					<a href="https://windowsontheory.org/2013/07/11/discrepancy-graphs-and-the-kadison-singer-conjecture-2/" class="bump-view" data-bump-view="tp">Discrepancy, Graphs, and the Kadison-Singer Problem</a>					</li>
								<li>
					<a href="https://windowsontheory.org/2018/05/29/cryptography-course-projects/" class="bump-view" data-bump-view="tp">Cryptography course projects</a>					</li>
								<li>
					<a href="https://windowsontheory.org/2020/01/21/summer-school-on-statistical-physics-and-machine-learning/" class="bump-view" data-bump-view="tp">Summer School on Statistical Physics and Machine Learning</a>					</li>
				</ul></aside><aside id="recent-comments-3" class="widget widget_recent_comments"><h1 class="widget-title">Recent Comments</h1>				<table class="recentcommentsavatar" cellspacing="0" cellpadding="0" border="0">
					<tbody><tr><td title="Yuval Filmus" class="recentcommentsavatartop" style="height:48px; width:48px;"><a href="http://gravatar.com/yuvalf" rel="nofollow"><img alt="" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/b5a2aa5bb3e3ffb92be80ffb5620a5b8.jpeg" class="avatar avatar-48 grav-hashed" id="grav-b5a2aa5bb3e3ffb92be80ffb5620a5b8-0" width="48" height="48"></a></td><td class="recentcommentstexttop" style=""><a href="http://gravatar.com/yuvalf" rel="nofollow">Yuval Filmus</a> on <a href="https://windowsontheory.org/2020/11/25/making-tcs-more-connected-less-insular/#comment-62398">Making TCS more connected / le…</a></td></tr><tr><td title="Boaz Barak" class="recentcommentsavatarend" style="height:48px; width:48px;"><a href="https://windowsontheory.wordpress.com/" rel="nofollow"><img alt="" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/ee47e3af6333d8a883d24155e0a6df50.png" class="avatar avatar-48 grav-hashed" id="grav-ee47e3af6333d8a883d24155e0a6df50-0" width="48" height="48"></a></td><td class="recentcommentstextend" style=""><a href="https://windowsontheory.wordpress.com/" rel="nofollow">Boaz Barak</a> on <a href="https://windowsontheory.org/2020/11/25/making-tcs-more-connected-less-insular/#comment-62397">Making TCS more connected / le…</a></td></tr><tr><td title="Mohammad Hajiaghayi" class="recentcommentsavatarend" style="height:48px; width:48px;"><img alt="" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/419a12a8b196e6f90b50f5e3fbc48649.png" class="avatar avatar-48 grav-hashed grav-hijack" id="grav-419a12a8b196e6f90b50f5e3fbc48649-0" width="48" height="48"></td><td class="recentcommentstextend" style="">Mohammad Hajiaghayi on <a href="https://windowsontheory.org/2020/11/25/making-tcs-more-connected-less-insular/#comment-62396">Making TCS more connected / le…</a></td></tr><tr><td title="Pascal" class="recentcommentsavatarend" style="height:48px; width:48px;"><img alt="" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/b84923fa156fe675ba1285d95b6191be.png" class="avatar avatar-48 grav-hashed grav-hijack" id="grav-b84923fa156fe675ba1285d95b6191be-0" width="48" height="48"></td><td class="recentcommentstextend" style="">Pascal on <a href="https://windowsontheory.org/2020/11/24/on-galileo-galilei-and-denialism-from-elections-to-climate-to-covid/#comment-62395">On Galileo Galilei and “…</a></td></tr><tr><td title="Adam" class="recentcommentsavatarend" style="height:48px; width:48px;"><img alt="" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/b19215a55e584552a34615c0a8e125aa.png" class="avatar avatar-48 grav-hashed grav-hijack" id="grav-b19215a55e584552a34615c0a8e125aa-0" width="48" height="48"></td><td class="recentcommentstextend" style="">Adam on <a href="https://windowsontheory.org/2020/11/24/on-galileo-galilei-and-denialism-from-elections-to-climate-to-covid/#comment-62394">On Galileo Galilei and “…</a></td></tr>				</tbody></table>
				</aside>
		<aside id="recent-posts-2" class="widget widget_recent_entries">
		<h1 class="widget-title">Recent Posts</h1>
		<ul>
											<li>
					<a href="https://windowsontheory.org/2020/12/03/obfuscation-the-season-4-finale/">Obfuscation: The season 4&nbsp;Finale</a>
											<span class="post-date">December 3, 2020</span>
									</li>
											<li>
					<a href="https://windowsontheory.org/2020/11/25/making-tcs-more-connected-less-insular/">Making TCS more connected / less&nbsp;insular</a>
											<span class="post-date">November 25, 2020</span>
									</li>
											<li>
					<a href="https://windowsontheory.org/2020/11/24/on-galileo-galilei-and-denialism-from-elections-to-climate-to-covid/">On Galileo Galilei and “denialism” from elections to climate to&nbsp;COVID</a>
											<span class="post-date">November 24, 2020</span>
									</li>
											<li>
					<a href="https://windowsontheory.org/2020/11/24/announcing-the-wiml-t-mentorship-program-guest-post/">Announcing the WiML-T Mentorship Program (guest&nbsp;post)</a>
											<span class="post-date">November 24, 2020</span>
									</li>
											<li>
					<a href="https://windowsontheory.org/2020/11/19/updated-research-masters-programs-database-by-aviad-rubinstein-and-matt-weinberg/">Updated Research Masters programs database by Aviad Rubinstein and Matt&nbsp;Weinberg</a>
											<span class="post-date">November 19, 2020</span>
									</li>
											<li>
					<a href="https://windowsontheory.org/2020/11/17/election-insecurity/">Election insecurity</a>
											<span class="post-date">November 17, 2020</span>
									</li>
											<li>
					<a href="https://windowsontheory.org/2020/11/12/mops-and-junior-senior-meeting-disc-2020/">MoPS and Junior-Senior Meeting (DISC&nbsp;2020)</a>
											<span class="post-date">November 12, 2020</span>
									</li>
					</ul>

		</aside><aside id="archives-2" class="widget widget_archive"><h1 class="widget-title">Archives</h1>		<label class="screen-reader-text" for="archives-dropdown-2">Archives</label>
		<select id="archives-dropdown-2" name="archive-dropdown">
			
			<option value="" selected="selected">Select Month</option>
				<option value="https://windowsontheory.org/2020/12/"> December 2020 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2020/11/"> November 2020 &nbsp;(7)</option>
	<option value="https://windowsontheory.org/2020/10/"> October 2020 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2020/09/"> September 2020 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2020/08/"> August 2020 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2020/07/"> July 2020 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2020/06/"> June 2020 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2020/05/"> May 2020 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2020/04/"> April 2020 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2020/03/"> March 2020 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2020/01/"> January 2020 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2019/12/"> December 2019 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2019/11/"> November 2019 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2019/10/"> October 2019 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2019/09/"> September 2019 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2019/08/"> August 2019 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2019/07/"> July 2019 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2019/06/"> June 2019 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2019/04/"> April 2019 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2019/03/"> March 2019 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2019/02/"> February 2019 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2019/01/"> January 2019 &nbsp;(6)</option>
	<option value="https://windowsontheory.org/2018/12/"> December 2018 &nbsp;(11)</option>
	<option value="https://windowsontheory.org/2018/11/"> November 2018 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2018/10/"> October 2018 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2018/09/"> September 2018 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2018/08/"> August 2018 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2018/07/"> July 2018 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2018/06/"> June 2018 &nbsp;(6)</option>
	<option value="https://windowsontheory.org/2018/05/"> May 2018 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2018/04/"> April 2018 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2018/03/"> March 2018 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2018/02/"> February 2018 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2018/01/"> January 2018 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2017/12/"> December 2017 &nbsp;(10)</option>
	<option value="https://windowsontheory.org/2017/11/"> November 2017 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2017/10/"> October 2017 &nbsp;(6)</option>
	<option value="https://windowsontheory.org/2017/09/"> September 2017 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2017/08/"> August 2017 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2017/07/"> July 2017 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2017/06/"> June 2017 &nbsp;(7)</option>
	<option value="https://windowsontheory.org/2017/05/"> May 2017 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2017/04/"> April 2017 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2017/03/"> March 2017 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2017/01/"> January 2017 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2016/12/"> December 2016 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2016/11/"> November 2016 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2016/10/"> October 2016 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2016/09/"> September 2016 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2016/08/"> August 2016 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2016/07/"> July 2016 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2016/06/"> June 2016 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2016/05/"> May 2016 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2016/04/"> April 2016 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2016/03/"> March 2016 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2016/02/"> February 2016 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2016/01/"> January 2016 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2015/12/"> December 2015 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2015/11/"> November 2015 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2015/10/"> October 2015 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2015/09/"> September 2015 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2015/08/"> August 2015 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2015/07/"> July 2015 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2015/06/"> June 2015 &nbsp;(8)</option>
	<option value="https://windowsontheory.org/2015/05/"> May 2015 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2015/04/"> April 2015 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2015/03/"> March 2015 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2015/01/"> January 2015 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2014/12/"> December 2014 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2014/11/"> November 2014 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2014/10/"> October 2014 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2014/09/"> September 2014 &nbsp;(6)</option>
	<option value="https://windowsontheory.org/2014/08/"> August 2014 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2014/07/"> July 2014 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2014/06/"> June 2014 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2014/04/"> April 2014 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2014/03/"> March 2014 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2014/02/"> February 2014 &nbsp;(6)</option>
	<option value="https://windowsontheory.org/2014/01/"> January 2014 &nbsp;(2)</option>
	<option value="https://windowsontheory.org/2013/12/"> December 2013 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2013/11/"> November 2013 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2013/10/"> October 2013 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2013/09/"> September 2013 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2013/08/"> August 2013 &nbsp;(6)</option>
	<option value="https://windowsontheory.org/2013/07/"> July 2013 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2013/06/"> June 2013 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2013/05/"> May 2013 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2013/04/"> April 2013 &nbsp;(8)</option>
	<option value="https://windowsontheory.org/2013/03/"> March 2013 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2013/02/"> February 2013 &nbsp;(7)</option>
	<option value="https://windowsontheory.org/2013/01/"> January 2013 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2012/12/"> December 2012 &nbsp;(1)</option>
	<option value="https://windowsontheory.org/2012/11/"> November 2012 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2012/10/"> October 2012 &nbsp;(7)</option>
	<option value="https://windowsontheory.org/2012/09/"> September 2012 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2012/08/"> August 2012 &nbsp;(3)</option>
	<option value="https://windowsontheory.org/2012/07/"> July 2012 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2012/06/"> June 2012 &nbsp;(4)</option>
	<option value="https://windowsontheory.org/2012/05/"> May 2012 &nbsp;(9)</option>
	<option value="https://windowsontheory.org/2012/04/"> April 2012 &nbsp;(5)</option>
	<option value="https://windowsontheory.org/2012/03/"> March 2012 &nbsp;(6)</option>
	<option value="https://windowsontheory.org/2012/02/"> February 2012 &nbsp;(5)</option>

		</select>

<script type="text/javascript">
/* <![CDATA[ */
(function() {
	var dropdown = document.getElementById( "archives-dropdown-2" );
	function onSelectChange() {
		if ( dropdown.options[ dropdown.selectedIndex ].value !== '' ) {
			document.location.href = this.options[ this.selectedIndex ].value;
		}
	}
	dropdown.onchange = onSelectChange;
})();
/* ]]> */
</script>
			</aside><aside id="rss_links-2" class="widget widget_rss_links"><h1 class="widget-title">RSS</h1><ul><li><a href="https://windowsontheory.org/feed/" title="Subscribe to Posts">RSS - Posts</a></li><li><a href="https://windowsontheory.org/comments/feed/" title="Subscribe to Comments">RSS - Comments</a></li></ul>
</aside><aside id="rss-5" class="widget widget_rss"><h1 class="widget-title"><a class="rsswidget" href="https://cstheory-jobs.org/feed/" title="Syndicate this content"><img style="background: orange; color: white; border: none;" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/rss.png" alt="RSS" width="14" height="14"></a> <a class="rsswidget" href="https://cstheory-jobs.org/" title="">Theory jobs</a></h1><ul><li><a class="rsswidget" href="https://cstheory-jobs.org/2021/01/08/samuel-eilenberg-assistant-professor-at-university-of-warsaw-apply-by-february-12-2020/" title="The Faculty of Mathematics, Informatics and Mechanics at University of Warsaw (MIM UW) invites applications for positions of an assistant professor (“adiunkt” in Polish) in Computer Science, starting on 1st October 2021 (or 1st Feb 2022). Note: compared to a standard assistant professor position, Samuel Eilenberg Assistant Professor comes with reduced teachi […]">Samuel Eilenberg Assistant Professor at University of Warsaw (apply by February 12, 2020)</a></li></ul></aside><aside id="rss-6" class="widget widget_rss"><h1 class="widget-title"><a class="rsswidget" href="https://thmatters.wordpress.com/feed/" title="Syndicate this content"><img style="background: orange; color: white; border: none;" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/rss.png" alt="RSS" width="14" height="14"></a> <a class="rsswidget" href="https://thmatters.wordpress.com/" title="">Theory matters</a></h1><ul><li><a class="rsswidget" href="https://thmatters.wordpress.com/2020/06/05/tcs-visioning-workshop-call-for-participation/" title="The CATCS will be hosting a virtual “Visioning Workshop” the week of July 20 in order to identify broad research themes within theoretical computer science (TCS) that have potential for a major impact in the future. The goals are similar to the workshop of the same name in 2008: to package these themes in a […]">TCS Visioning Workshop — Call for Participation</a></li></ul></aside><aside id="rss-8" class="widget widget_rss"><h1 class="widget-title"><a class="rsswidget" href="https://theorydish.blog/feed/" title="Syndicate this content"><img style="background: orange; color: white; border: none;" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/rss.png" alt="RSS" width="14" height="14"></a> <a class="rsswidget" href="https://theorydish.blog/" title="Stanford's CS Theory Research Blog">Theory Dish</a></h1><ul><li><a class="rsswidget" href="https://theorydish.blog/2020/12/01/motwani-postdoc-announced/" title="After discussing postdoc opportunities with me and the opportunities as part of the Simons Collaboration on the Theory of Algorithmic Fairness, let me conclude with postdoc opportunities with Stanford theory group: The theory group at Stanford invites applications for the Motwani postdoctoral fellowship in theoretical computer science. Information and applic […]">Motwani Postdoc Announced</a></li></ul></aside>	</div><!-- #secondary -->

	</div><!-- #content -->

	<footer id="colophon" class="site-footer" role="contentinfo">
				<div class="site-info-wrapper clear">
						<div class="site-info">
				<a href="https://wordpress.com/?ref=footer_blog" rel="nofollow">Blog at WordPress.com.</a>
				
							</div><!-- .site-info -->
		</div><!-- .site-info-wrapper -->
	</footer><!-- #colophon -->
</div><!-- #page -->

<!--  -->
<script src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/gprofiles.js" id="grofiles-cards-js"></script>
<script id="wpgroho-js-extra">
var WPGroHo = {"my_hash":""};
</script>
<script type="text/javascript" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/wpgroho.js"></script>

	<script>
		//initialize and attach hovercards to all gravatars
		jQuery( document ).ready( function( $ ) {

			if (typeof Gravatar === "undefined"){
				return;
			}

			if ( typeof Gravatar.init !== "function" ) {
				return;
			}			

			Gravatar.profile_cb = function( hash, id ) {
				WPGroHo.syncProfileData( hash, id );
			};
			Gravatar.my_hash = WPGroHo.my_hash;
			Gravatar.init( 'body', '#wp-admin-bar-my-account' );
		});
	</script>

		<div style="display:none">
	<div class="grofile-hash-map-8c5c9e238d6dc6aba53adb08facb1313">
	</div>
	<div class="grofile-hash-map-b5a2aa5bb3e3ffb92be80ffb5620a5b8">
	</div>
	<div class="grofile-hash-map-ee47e3af6333d8a883d24155e0a6df50">
	</div>
	<div class="grofile-hash-map-419a12a8b196e6f90b50f5e3fbc48649">
	</div>
	<div class="grofile-hash-map-b84923fa156fe675ba1285d95b6191be">
	</div>
	<div class="grofile-hash-map-b19215a55e584552a34615c0a8e125aa">
	</div>
	</div>

<script>
window.addEventListener( "load", function( event ) {
	var link = document.createElement( "link" );
	link.href = "https://s0.wp.com/wp-content/mu-plugins/actionbar/actionbar.css?v=20201002";
	link.type = "text/css";
	link.rel = "stylesheet";
	document.head.appendChild( link );

	var script = document.createElement( "script" );
	script.src = "https://s0.wp.com/wp-content/mu-plugins/actionbar/actionbar.js?v=20201002";
	script.defer = true;
	document.body.appendChild( script );
} );
</script>

	
	<div id="carousel-reblog-box">
		<form action="#" name="carousel-reblog">
			<label for="carousel-reblog-content" id="carousel-reblog-lblogcontent" class="screen-reader-text">Add your thoughts here... (optional)</label>
			<textarea id="carousel-reblog-content" name="carousel-reblog-content" placeholder="Add your thoughts here... (optional)"></textarea>
			<label for="carousel-reblog-to-blog-id" id="carousel-reblog-lblogid">Post to</label>
			<select name="carousel-reblog-to-blog-id" id="carousel-reblog-to-blog-id">
						</select>

			<div class="submit">
				<span class="canceltext"><a href="#" class="cancel">Cancel</a></span>
				<input type="submit" name="carousel-reblog-submit" class="button" id="carousel-reblog-submit" value="Reblog Post">
				<input type="hidden" id="carousel-reblog-blog-id" value="32349634">
				<input type="hidden" id="carousel-reblog-blog-url" value="https://windowsontheory.org">
				<input type="hidden" id="carousel-reblog-blog-title" value="Windows On Theory">
				<input type="hidden" id="carousel-reblog-post-url" value="">
				<input type="hidden" id="carousel-reblog-post-title" value="">
			</div>

			<input type="hidden" id="_wpnonce" name="_wpnonce" value="371e3b23a5"><input type="hidden" name="_wp_http_referer" value="/2018/12/16/algorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code/">		</form>

		<div class="arrow"></div>
	</div>

	<script type="text/javascript">
		window.WPCOM_sharing_counts = {"https:\/\/windowsontheory.org\/2018\/12\/16\/algorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code\/":6363};
	</script>
				<link rel="stylesheet" id="all-css-0-2" href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/jetpack-carousel.css" type="text/css" media="all">
<script id="jetpack-carousel-js-extra">
var jetpackCarouselStrings = {"widths":[370,700,1000,1200,1400,2000],"is_logged_in":"","lang":"en","ajaxurl":"https:\/\/windowsontheory.org\/wp-admin\/admin-ajax.php","nonce":"22727133d6","display_exif":"1","display_comments":"1","display_geo":"1","single_image_gallery":"1","single_image_gallery_media_file":"","background_color":"black","comment":"Comment","post_comment":"Post Comment","write_comment":"Write a Comment...","loading_comments":"Loading Comments...","download_original":"View full size <span class=\"photo-size\">{0}<span class=\"photo-size-times\">\u00d7<\/span>{1}<\/span>","no_comment_text":"Please be sure to submit some text with your comment.","no_comment_email":"Please provide an email address to comment.","no_comment_author":"Please provide your name to comment.","comment_post_error":"Sorry, but there was an error posting your comment. Please try again later.","comment_approved":"Your comment was approved.","comment_unapproved":"Your comment is in moderation.","camera":"Camera","aperture":"Aperture","shutter_speed":"Shutter Speed","focal_length":"Focal Length","copyright":"Copyright","comment_registration":"0","require_name_email":"1","login_url":"https:\/\/windowsontheory.wordpress.com\/wp-login.php?redirect_to=https%3A%2F%2Fwindowsontheory.org%2F2018%2F12%2F16%2Falgorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code%2F","blog_id":"32349634","meta_data":["camera","aperture","shutter_speed","focal_length","copyright"],"local_comments_commenting_as":"<fieldset><label for=\"email\">Email (Required)<\/label> <input type=\"text\" name=\"email\" class=\"jp-carousel-comment-form-field jp-carousel-comment-form-text-field\" id=\"jp-carousel-comment-form-email-field\" \/><\/fieldset><fieldset><label for=\"author\">Name (Required)<\/label> <input type=\"text\" name=\"author\" class=\"jp-carousel-comment-form-field jp-carousel-comment-form-text-field\" id=\"jp-carousel-comment-form-author-field\" \/><\/fieldset><fieldset><label for=\"url\">Website<\/label> <input type=\"text\" name=\"url\" class=\"jp-carousel-comment-form-field jp-carousel-comment-form-text-field\" id=\"jp-carousel-comment-form-url-field\" \/><\/fieldset>","reblog":"Reblog","reblogged":"Reblogged","reblog_add_thoughts":"Add your thoughts here... (optional)","reblogging":"Reblogging...","post_reblog":"Post Reblog","stats_query_args":"blog=32349634&v=wpcom&tz=-5&user_id=0&subd=windowsontheory","is_public":"1","reblog_enabled":""};
</script>
<script id="sharing-js-js-extra">
var sharing_js_options = {"lang":"en","counts":"1","is_stats_active":"1"};
</script>
<script type="text/javascript" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/a_002.js"></script>
<script type="text/javascript">
var windowOpen;
			document.body.addEventListener( 'click', function ( event ) {
				if ( event.target && (
					event.target.matches && event.target.matches( 'a.share-twitter' ) ||
					event.target.msMatchesSelector && event.target.msMatchesSelector( 'a.share-twitter' )
				) ) {
					// If there's another sharing window open, close it.
					if ( typeof windowOpen !== 'undefined' ) {
						windowOpen.close();
					}
					windowOpen = window.open( event.target.getAttribute( 'href' ), 'wpcomtwitter', 'menubar=1,resizable=1,width=600,height=350' );
					return false;
				}
			} );
</script>
<script type="text/javascript">
// <![CDATA[
(function() {
try{
  if ( window.external &&'msIsSiteMode' in window.external) {
    if (window.external.msIsSiteMode()) {
      var jl = document.createElement('script');
      jl.type='text/javascript';
      jl.async=true;
      jl.src='/wp-content/plugins/ie-sitemode/custom-jumplist.php';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(jl, s);
    }
  }
}catch(e){}
})();
// ]]>
</script>		<iframe src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/master.html" scrolling="no" id="likes-master" name="likes-master" style="display:none;"></iframe>
		<div id="likes-other-gravatars"><div class="likes-text"><span>%d</span> bloggers like this:</div><ul class="wpl-avatars sd-like-gravatars"></ul></div>
<script src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/w.js" defer="defer"></script> <script type="text/javascript">
_tkq = window._tkq || [];
_stq = window._stq || [];
_tkq.push(['storeContext', {'blog_id':'32349634','blog_tz':'-5','user_lang':'en','blog_lang':'en','user_id':'0'}]);
_stq.push(['view', {'blog':'32349634','v':'wpcom','tz':'-5','user_id':'0','post':'6363','subd':'windowsontheory'}]);
_stq.push(['extra', {'crypt':'UE40eW5QN0p8M2Y/RE1TaVhzUzFMbjdWNHpwZGhTayxPSUFCMGRVYVNrSFguN3FwSmQ5RGtNX3VQcj1yVzhiflM1THQtLGFdQ2toOXYlK2lYQj1PZnRQXWxBbC4sa1YmNl8vOHk1JjhadWtvMCYyS0JLQnJuZHQ2dH5fZms4ak9RN1FkRmIyWCtNUWVBW1VMQU9IRkQvZGRQX0YvU1hndVR6ayx5bCVobnRfempTUXZ4M1BhfldQNk9Gd3olMG84JmkrT1h1a1NmQ3o1W1EtdyVMQz9ITy1LMTRaaDZhWUNpbXMtUkplPStEbDNRVjBrMy9OLis0W2VIdFl0MUtbdUhdPTYsTjRUWzhFXS1oRTcmZDZkLzhILEdMLFpaTFRrfDlyZlV6bXRka0Z8blcyWzJzJVdkSVtyJXdBYTNLVno2Ri1NY044LDloYV0tK1pvNl9jWk9bYlVjMHkzdVpFUjE3R0o='}]);
_stq.push([ 'clickTrackerInit', '32349634', '6363' ]);
	</script>
<noscript><img src="https://pixel.wp.com/b.gif?v=noscript" style="height:1px;width:1px;overflow:hidden;position:absolute;bottom:1px;" alt="" /></noscript>
<script>
if ( 'object' === typeof wpcom_mobile_user_agent_info ) {

	wpcom_mobile_user_agent_info.init();
	var mobileStatsQueryString = "";
	
	if( false !== wpcom_mobile_user_agent_info.matchedPlatformName )
		mobileStatsQueryString += "&x_" + 'mobile_platforms' + '=' + wpcom_mobile_user_agent_info.matchedPlatformName;
	
	if( false !== wpcom_mobile_user_agent_info.matchedUserAgentName )
		mobileStatsQueryString += "&x_" + 'mobile_devices' + '=' + wpcom_mobile_user_agent_info.matchedUserAgentName;
	
	if( wpcom_mobile_user_agent_info.isIPad() )
		mobileStatsQueryString += "&x_" + 'ipad_views' + '=' + 'views';

	if( "" != mobileStatsQueryString ) {
		new Image().src = document.location.protocol + '//pixel.wp.com/g.gif?v=wpcom-no-pv' + mobileStatsQueryString + '&baba=' + Math.random();
	}
	
}
</script>


<img src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/g.gif" alt=":)" id="wpstats"><iframe scrolling="no" allowtransparency="true" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/widget_iframe.html" title="Twitter settings iframe" style="display: none;" frameborder="0"></iframe><script src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/actionbar.js" defer="defer"></script><div id="actionbar" class="actnbr-pub-penscratch-2 actnbr-has-follow"><ul><li class="actnbr-btn actnbr-hidden"> 				<a class="actnbr-action actnbr-actn-follow" href=""><svg class="gridicon gridicon__follow" height="24px" width="24px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M23 16v2h-3v3h-2v-3h-3v-2h3v-3h2v3h3zM20 2v9h-4v3h-3v4H4c-1.1 0-2-.9-2-2V2h18zM8 13v-1H4v1h4zm3-3H4v1h7v-1zm0-2H4v1h7V8zm7-4H4v2h14V4z"></path></g></svg><span>Follow</span></a><a class="actnbr-action actnbr-actn-following no-display" href=""><svg class="gridicon gridicon__following" height="24px" width="24px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M23 13.482L15.508 21 12 17.4l1.412-1.388 2.106 2.188 6.094-6.094L23 13.482zm-7.455 1.862L20 10.89V2H2v14c0 1.1.9 2 2 2h4.538l4.913-4.832 2.095 2.176zM8 13H4v-1h4v1zm3-2H4v-1h7v1zm0-2H4V8h7v1zm7-3H4V4h14v2z"></path></g></svg><span>Following</span></a> 				<div class="actnbr-popover tip tip-top-left actnbr-notice"> 					<div class="tip-arrow"></div> 					<div class="tip-inner actnbr-follow-bubble"> 				<ul> 					<li class="actnbr-sitename actnbr-hidden"><a href="https://windowsontheory.org/"><img alt="" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/wpcom-gray-white.png" class="avatar avatar-50" width="50" height="50"> Windows On Theory</a></li> 					<form> 					<li class="actnbr-login-nudge actnbr-hidden"><div>Already have a WordPress.com account? <a href="https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fwindowsontheory.org%2F2018%2F12%2F16%2Falgorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code%2F&amp;signup_flow=account&amp;domain=windowsontheory.org">Log in now.</a></div></li> 				</form></ul> 			</div> 				</div> 					</li><li class="actnbr-ellipsis actnbr-hidden"> 				<svg class="gridicon gridicon__ellipsis" height="24" width="24" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><circle cx="5" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="12" cy="12" r="2"></circle></g></svg> 				<div class="actnbr-popover tip tip-top-left actnbr-more"> 				<div class="tip-arrow"></div> 				<div class="tip-inner"> 					<ul> 						<li class="actnbr-sitename actnbr-hidden"><a href="https://windowsontheory.org/"><img alt="" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/wpcom-gray-white.png" class="avatar avatar-50" width="50" height="50"> Windows On Theory</a></li> 					<li class="actnbr-folded-customize actnbr-hidden"><a href="https://windowsontheory.wordpress.com/wp-admin/customize.php?url=https%3A%2F%2Fwindowsontheory.wordpress.com%2F2018%2F12%2F16%2Falgorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code%2F"><svg class="gridicon gridicon__customize" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M2 6c0-1.505.78-3.08 2-4 0 .845.69 2 2 2 1.657 0 3 1.343 3 3 0 .386-.08.752-.212 1.09.74.594 1.476 1.19 2.19 1.81L8.9 11.98c-.62-.716-1.214-1.454-1.807-2.192C6.753 9.92 6.387 10 6 10c-2.21 0-4-1.79-4-4zm12.152 6.848l1.34-1.34c.607.304 1.283.492 2.008.492 2.485 0 4.5-2.015 4.5-4.5 0-.725-.188-1.4-.493-2.007L18 9l-2-2 3.507-3.507C18.9 3.188 18.225 3 17.5 3 15.015 3 13 5.015 13 7.5c0 .725.188 1.4.493 2.007L3 20l2 2 6.848-6.848c1.885 1.928 3.874 3.753 5.977 5.45l1.425 1.148 1.5-1.5-1.15-1.425c-1.695-2.103-3.52-4.092-5.448-5.977z" data-reactid=".2.1.1:0.1b.0"></path></g></svg><span>Customize<span></span></span></a></li> 						<li class="actnbr-folded-follow actnbr-hidden"><a class="actnbr-action actnbr-actn-follow" href=""><svg class="gridicon gridicon__follow" height="24px" width="24px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M23 16v2h-3v3h-2v-3h-3v-2h3v-3h2v3h3zM20 2v9h-4v3h-3v4H4c-1.1 0-2-.9-2-2V2h18zM8 13v-1H4v1h4zm3-3H4v1h7v-1zm0-2H4v1h7V8zm7-4H4v2h14V4z"></path></g></svg><span>Follow</span></a><a class="actnbr-action actnbr-actn-following no-display" href=""><svg class="gridicon gridicon__following" height="24px" width="24px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M23 13.482L15.508 21 12 17.4l1.412-1.388 2.106 2.188 6.094-6.094L23 13.482zm-7.455 1.862L20 10.89V2H2v14c0 1.1.9 2 2 2h4.538l4.913-4.832 2.095 2.176zM8 13H4v-1h4v1zm3-2H4v-1h7v1zm0-2H4V8h7v1zm7-3H4V4h14v2z"></path></g></svg><span>Following</span></a></li> 					<li class="actnbr-signup actnbr-hidden"><a href="https://wordpress.com/start/">Sign up</a></li> 						<li class="actnbr-login actnbr-hidden"><a href="https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fwindowsontheory.org%2F2018%2F12%2F16%2Falgorithmic-and-information-theoretic-decoding-thresholds-for-low-density-parity-check-code%2F&amp;signup_flow=account&amp;domain=windowsontheory.org">Log in</a></li> 						 						<li class="actnbr-shortlink actnbr-hidden"><a href="https://wp.me/p2bJCi-1ED">Copy shortlink</a></li> 						<li class="flb-report actnbr-hidden"><a href="http://en.wordpress.com/abuse/">Report this content</a></li> 						 						 						<li class="actnbr-subs actnbr-hidden"><a href="https://subscribe.wordpress.com/">Manage subscriptions</a></li> 						<li class="actnbr-fold actnbr-hidden"><a href="">Collapse this bar</a></li> 						</ul> 					</div> 					</div> 				</li> 				</ul></div><!-- admin_bar -->
<script type="text/javascript" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/jquery.js"></script>
<!-- admin_bar_css -->

			<style type="text/css">
			div.ab-sub-wrapper { visibility: hidden; }
			html { -webkit-transition: margin-top 1s; transition: margin-top 1s; }
			</style>
<style type="text/css" media="screen">
	html { margin-top: 32px !important; }
	* html body { margin-top: 32px !important; }
	@media screen and ( max-width: 782px ) {
		html { margin-top: 46px !important; }
		* html body { margin-top: 46px !important; }
	}
</style>
	<link rel="stylesheet" id="all-css-0-1" href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/a_002.css" type="text/css" media="all">
<!-- /admin_bar_css -->
		<div id="wpadminbar" class="nojq nojs ltr">
							<a class="screen-reader-shortcut" href="#wp-toolbar" tabindex="1">Skip to toolbar</a>
						<div class="quicklinks" id="wp-toolbar" role="navigation" aria-label="Toolbar" tabindex="0">
						<ul id="wp-admin-bar-root-default" class="ab-top-menu">
			
		<li id="wp-admin-bar-blog" class="my-sites mb-trackable"><a class="ab-item" href="https://wordpress.com/sites/windowsontheory.org">My Site</a>		</li>
		<li id="wp-admin-bar-jumptotop-button-menu"><a class="ab-item" href="#"><div id="jumptotop"><span class="noticon noticon-top"></span></div></a>		</li>
		<li id="wp-admin-bar-newdash" class="mb-trackable"><a class="ab-item" href="https://wordpress.com/read">Reader</a>		</li>		</ul>
			<ul id="wp-admin-bar-top-secondary" class="ab-top-secondary ab-top-menu">
			
		<li id="wp-admin-bar-notes" class="menupop">		<div class="ab-item ab-empty-item"><span id="wpnt-notes-unread-count" class="wpnt-loading wpn-read"></span><span class="noticon noticon-bell"></span><span class="ab-text">Notifications</span></div><div id="wpnt-notes-panel2" style="display:none" dir="ltr" lang="en"><div class="wpnt-notes-panel-header"><span class="wpnt-notes-header"></span><span class="wpnt-notes-panel-link"></span></div></div>		</li>
		<li id="wp-admin-bar-my-account" class="with-avatar mb-trackable"><a class="ab-item" href="https://wordpress.com/me/"><img alt="" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/8c5c9e238d6dc6aba53adb08facb1313.jpeg" class="avatar avatar-32" width="32" height="32"><span class="ab-text">Me</span></a>		</li>
		<li id="wp-admin-bar-ab-new-post" class="mb-trackable"><a class="ab-item" href="https://wordpress.com/post/windowsontheory.org"><span>Write</span></a>		</li>		</ul>
				</div>
							<a class="screen-reader-shortcut" href="https://windowsontheory.wordpress.com/wp-login.php?action=logout&amp;_wpnonce=6c2c55228d">Log Out</a>
					</div>

	<!-- admin_bar_js -->
<!-- /admin_bar_js -->
<!-- /admin_bar -->
<link rel="stylesheet" id="all-css-0-2" href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/a.css" type="text/css" media="all">
<script id="thickbox-js-extra">
var thickboxL10n = {"next":"Next >","prev":"< Prev","image":"Image","of":"of","close":"Close","noiframes":"This feature requires inline frames. You have iframes disabled or your browser does not support them.","loadingAnimation":"https:\/\/s0.wp.com\/wp-includes\/js\/thickbox\/loadingAnimation.gif"};
</script>
<script type="text/javascript" src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/a_003.js"></script>
<script type="text/javascript">
// <![CDATA[
(function() {
try{
  if ( window.external &&'msIsSiteMode' in window.external) {
    if (window.external.msIsSiteMode()) {
      var jl = document.createElement('script');
      jl.type='text/javascript';
      jl.async=true;
      jl.src='/wp-content/plugins/ie-sitemode/custom-jumplist.php';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(jl, s);
    }
  }
}catch(e){}
})();
// ]]>
</script><!-- notifications -->
<!-- notifications_css -->
<link rel="stylesheet" id="all-css-0-3" href="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/admin-bar-v2.css" type="text/css" media="all">
<!-- notifications_css -->
<!-- notifications_js -->

<script type="text/javascript">
jQuery(document.body).addClass('admin-bar')
var wpNotesArgs = {"cacheBuster":"@automattic\/jetpack-blocks@13.1.0-10451-g9f7e375b88","iframeUrl":"https:\/\/widgets.wp.com\/notifications\/","iframeAppend":"2","iframeScroll":"no","wide":true,"beta":null}
jQuery.getScript("\/wp-content\/js\/mustache.js?m=1365102487h&ver=%40automattic%2Fjetpack-blocks%4013.1.0-10451-g9f7e375b88", function() {
jQuery.getScript("\/wp-includes\/js\/underscore.min.js?m=1582644500h&ver=1.8.3", function() {
jQuery.getScript("\/wp-includes\/js\/backbone.min.js?m=1582644500h&ver=1.4.0", function() {
jQuery.getScript("https:\/\/s0.wp.com\/wp-includes\/js\/spin.js?m=1370534259h&ver=1.3", function() {
jQuery.getScript("https:\/\/s0.wp.com\/wp-includes\/js\/jquery\/jquery.spin.js?m=1370534259h&ver=1.3", function() {
jQuery.getScript("https:\/\/s0.wp.com\/wp-content\/mu-plugins\/notes\/notes-common-v2.js?m=1408416055h&ver=%40automattic%2Fjetpack-blocks%4013.1.0-10451-g9f7e375b88", function() {
jQuery.getScript("https:\/\/s0.wp.com\/wp-content\/mu-plugins\/notes\/admin-bar-v2.js?m=1605096953h&ver=%40automattic%2Fjetpack-blocks%4013.1.0-10451-g9f7e375b88", function() {
jQuery(document.body).append("<style type='text\/css'>div.ab-sub-wrapper { visibility: visible; }<\/style>\n");

})
})
})
})
})
})
})

</script>
<!-- /notifications_js -->
<!-- /notifications -->
<script>jQuery( '#actionbar' ).remove();actionbardata.isLoggedIn = 1;actionbardata.nonce = 'de2138065a';</script><script src="Algorithmic%20and%20Information%20Theoretic%20Decoding%20Thresholds%20for%20Low%20density%20Parity-Check%20Code%20%E2%80%93%20Windows%20On%20Theory_files/actionbar_002.js"></script><iframe id="rufous-sandbox" scrolling="no" allowtransparency="true" allowfullscreen="true" style="position: absolute; visibility: hidden; display: none; width: 0px; height: 0px; padding: 0px; border: medium none;" title="Twitter analytics iframe" frameborder="0"></iframe></body></html>